<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="愿你仗剑走天涯，归来仍是少年">
<meta property="og:type" content="website">
<meta property="og:title" content="哺乳类的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="哺乳类的博客">
<meta property="og:description" content="愿你仗剑走天涯，归来仍是少年">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="哺乳类的博客">
<meta name="twitter:description" content="愿你仗剑走天涯，归来仍是少年">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>哺乳类的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">哺乳类的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/07/JMeter01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/07/JMeter01/" itemprop="url">Apache JMeter 的使用入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-07T15:17:55+08:00">
                2019-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Apache-JMeter/" itemprop="url" rel="index">
                    <span itemprop="name">Apache JMeter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Apache-JMeter-的使用入门"><a href="#Apache-JMeter-的使用入门" class="headerlink" title="Apache JMeter 的使用入门"></a>Apache JMeter 的使用入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache JMeter 是一款开源的 Java 应用程序，用于加载测试功能行为和度量性能。</p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li>下载地址：<a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">https://jmeter.apache.org/download_jmeter.cgi</a></li>
<li><p>下载文件：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i01d1dx4j31e70u8agn.jpg" alt="JMeter 软件压缩包"></p>
</li>
<li><p>压缩包是 Linux 和 Windows 通用的，直接解压即可。</p>
</li>
</ol>
<h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><ol>
<li>找到文件解压路径，进入对应 bin 目录下，windows 就直接点击运行 jmeter.bat<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i0808r3hj310l0ph0wy.jpg" alt="1"></li>
<li>添加一个线程组<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i0d1wpg8j318d0s2763.jpg" alt="2"></li>
<li>添加完成之后，先设置这两项<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i0eo4ssnj316o0o0q4r.jpg" alt="3"></li>
<li>添加一个http请求<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i0l8dkl0j31290q0tb0.jpg" alt="4"></li>
<li>填入配置信息<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i0lbtwv4j316o0o040e.jpg" alt="5"></li>
<li>点击保存，保存的文件路径自己指定，保存完之后，是一个jmx文件<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i0rss5luj30zm0ordhr.jpg" alt="6"></li>
<li>添加查看结果树<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i12xxx4qj31290qkjtr.jpg" alt="7"><br>还可以添加表格结果、图形结果和聚合结果等。</li>
<li>启动测试<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i1517cycj312b0rndja.jpg" alt="8"></li>
</ol>
<h2 id="更多操作指南"><a href="#更多操作指南" class="headerlink" title="更多操作指南"></a>更多操作指南</h2><p><a href="https://jmeter.apache.org/usermanual/jmeter_proxy_step_by_step.html" target="_blank" rel="noopener">查看官网的操作指南</a><br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3i1bromxpj31z412m140.jpg" alt="9"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/07/ARTS0011/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/07/ARTS0011/" itemprop="url">ARTS打卡：第十一周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-07T11:38:34+08:00">
                2019-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第十一周"><a href="#ARTS打卡：第十一周" class="headerlink" title="ARTS打卡：第十一周"></a>ARTS打卡：第十一周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="1-Two-Sum-Easy"><a href="#1-Two-Sum-Easy" class="headerlink" title="1. Two Sum(Easy)"></a>1. Two Sum(Easy)</h3><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
undefined
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">leetcode.com/problems/two-sum</a></cite></footer></blockquote>
<p><strong>大致题意</strong><br>给一个整形数组，返回两个数组下标，两个数组下标对应的值相加，要等于目标值。<br>你可以假设每一个输入的数组，只有一种答案，并且你不能使用同一个元素两次。</p>
<p>这种题目，一眼看上去，是可以用暴力破解的，不过暴力破解虽然能解决问题，但我们这种三好青年，是有追求，有梦想的，用最少的时间和空间去解决问题，才是我们的终极目标。</p>
<p><strong>解题思路一：暴力破解，双重遍历</strong><br>这种解法就简单直接了，双重循环遍历即可</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力破解，双重遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums   输入数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 18 ms, faster than 38.89% of Java online submissions for Two Sum.<br>Memory Usage: 38.2 MB, less than 94.24% of Java online submissions for Two Sum.</p>
<p>从结果上看，我们还是有很大优化空间的。</p>
<p>复杂度分析：<br>时间复杂度：O(n²)<br>空间复杂度：O(1)</p>
<p><strong>解题思路二：借助哈希表，空间换时间，优化遍历</strong><br>可以利用哈希表的特性，减少遍历次数，详细实现不难，直接看代码即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 借助哈希表进行优化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums   输入数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个 HashMap，key 为数组的值，value 为值对应的数组下标</span></span><br><span class="line">    <span class="comment">// 用于记录遍历过的数组的值与下标，便于快速查找到所需的值</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 循环遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 我们的目的是找到符合 nums[i] + nums[j] = target 的 i 和 j，t 就是 nums[j]</span></span><br><span class="line">        <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">        <span class="comment">// 查看 t 是否在已访问过的数组值内 即哈希表的 keys 包不包含 t，</span></span><br><span class="line">        <span class="comment">// 加上由于题目要求同一个元素不能使用两次，所以还需满足当前下标 i 不能与 hash.get(t) 的值一致</span></span><br><span class="line">        <span class="comment">// 即 hash.containsKey(t) &amp;&amp; hash.get(t) != i</span></span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(t) &amp;&amp; hash.get(t) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hash.get(t), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录已访问过的，数组的值与下标</span></span><br><span class="line">        hash.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 2 ms, faster than 99.20% of Java online submissions for Two Sum.<br>Memory Usage: 37.4 MB, less than 99.67% of Java online submissions for Two Sum.</p>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读是：<a href="https://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/" target="_blank" rel="noopener">《Top 10 Mistakes Java Developers Make》</a>。</p>
<p>作者在文中总结了 Java 开发人员经常犯的十大错误：</p>
<ol>
<li>Convert Array to ArrayList（Array 转 ArrayList）</li>
<li>Check If an Array Contains a Value（检查数组是否包含某个值）</li>
<li>Remove an Element from a List Inside a Loop（从 List 的循环中删除 List 的元素）</li>
<li>Hashtable vs HashMap</li>
<li>Use Raw Type of Collection（使用原始类型的集合）</li>
<li>Access Level（访问级别）</li>
<li>ArrayList vs. LinkedList</li>
<li>Mutable vs. Immutable（可变与不可变）</li>
<li>Constructor of Super and Sub（父类和子类的构造函数）</li>
<li>“” or Constructor?（”” 或构造函数）</li>
</ol>
<p>作者在文中对每点错误都进行了详细的分析，并给出了对应的解决方案或说明。<br>文中的英语其实不难理解，感兴趣的小伙伴们，可以通过<a href="https://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/" target="_blank" rel="noopener">原文</a>了解更多的详情。<br>如果实在不想看英语，那可以看看这篇译文：<a href="https://www.cnblogs.com/chenpi/p/5508949.html" target="_blank" rel="noopener">Java开发人员最常犯的10个错误</a>。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周分享：<a href="https://zyszero.github.io/2019/06/07/JMeter01/" target="_blank" rel="noopener">Apache JMeter 的使用入门</a>。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享猪猪大佬的公众号-<strong>工匠人生</strong>中的一篇文章：<a href="https://mp.weixin.qq.com/s/L4fc7IAnyMlY8-1kLbRBqw" target="_blank" rel="noopener">《如何将长URL转换为短URL？》</a><br>通过这篇文章，我们可以了解到：</p>
<ul>
<li>如何将长URL生成短URL</li>
<li>短地址从URL输入到页面展现到底发生了什么？</li>
<li>短连接的设计思路</li>
<li>发号器的设计思路</li>
<li>知乎关于生成短地址的讨论</li>
</ul>
<p>这里摘取一部分文中提到的，参考文章的地址：</p>
<ol>
<li><a href="https://hufangyun.com/2017/short-url/" target="_blank" rel="noopener">短网址(short URL)系统的原理及其实现</a></li>
<li><a href="https://www.zhihu.com/question/29270034/answer/46446911" target="_blank" rel="noopener">短 URL 系统是怎么设计的？</a></li>
<li><a href="https://stackoverflow.com/questions/742013/how-do-i-create-a-url-shortener" target="_blank" rel="noopener">How do I create a URL shortener?</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/ARTS0010/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/02/ARTS0010/" itemprop="url">ARTS打卡：第十周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T13:29:25+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第十周"><a href="#ARTS打卡：第十周" class="headerlink" title="ARTS打卡：第十周"></a>ARTS打卡：第十周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="66-Plus-One-Easy"><a href="#66-Plus-One-Easy" class="headerlink" title="66. Plus One(Easy)"></a>66. Plus One(Easy)</h3><blockquote><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.</p>
<p><strong>Example 2:</strong></p>
<p>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">leetcode.com/problems/plus-one</a></cite></footer></blockquote>
<p>题意：</p>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>解题思路：</p>
<p>这道题就非常简单了，利用数学的加法运算思想，倒序遍历数组，如果当前值不等于9，直接加1，然后返回数组，若等于 9，9 + 1 = 10，需要进位，把当前值设为 0，继续遍历数组，依次类推，若最后数组能遍历完，则表明输入数组的值全为9，+1 后，位数发生变化，结果一定是首位为 1，余位为 0 的数组， 所以要重新创建一个数组 result，大小为输入数组的长度 +1，result[0] 设为 1，然后返回数组 result。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="comment">//倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 不为9，则直接+1，返回结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为9，9+1=10，需进位，当前值设为 0</span></span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输入数组的值全为 9，+1 后位数也要 +1，结果一定是首位为 1，余位为 0 的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 利用整形数组初始化后，值为0的特性，只需对数组首位赋值</span></span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Plus One.<br>Memory Usage: 34.2 MB, less than 100.00% of Java online submissions for Plus One.</p>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="283-Move-Zeroes-Easy"><a href="#283-Move-Zeroes-Easy" class="headerlink" title="283. Move Zeroes(Easy)"></a>283. Move Zeroes(Easy)</h3><blockquote><p>Given an array <code>nums</code>, write a function to move all <code>0&#39;s</code> to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Example:</strong></p>
<p>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]</p>
<p><strong>Note:</strong></p>
<p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">leetcode.com/problems/move-zeroes</a></cite></footer></blockquote>
<p>题意：</p>
<p>给定一个数组 nums，写一个函数将所有 <code>0</code> 移动至数组末尾，同时保持数组内非零元素的相对顺序。<br><strong>注意：</strong></p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组</li>
<li>尽量减少操作次数</li>
</ol>
<p>解题思路：</p>
<p>由于题目要求要在原数组上操作，不能用额外的数组空间，那我们可以先从如何复用原数组空间出发，结合要求，去解题。</p>
<p>因为要将所有 0 移动至数组末尾且不可改变非零元素的相对位置，那么逐步交换 0 与非零元素的位置即可实现；考虑到要复用原数组空间且减少操作步骤，我们可以不交换位置，逐步将非零元素覆盖 0，直至所有 0 都被覆盖，最后末尾补零即可。</p>
<p>细节请参看代码实现</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个锚点，从 0 开始</span></span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历输入数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 判断当前元素是否为非零元素</span></span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不为零，则用当前的值覆盖锚点对应的数组的值，并将锚点往前移动一位</span></span><br><span class="line">            nums[anchor++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为零，锚点不移动，数组继续遍历，依次类推，就能实现非零元素覆盖 0 元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过上述遍历覆盖之后，锚点之前，皆为非零元素，锚点之后，应该全为零</span></span><br><span class="line">    <span class="keyword">while</span> (anchor &lt; nums.length) &#123;</span><br><span class="line">        nums[anchor++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Move Zeroes.<br>Memory Usage: 36.8 MB, less than 99.94% of Java online submissions for Move Zeroes.</p>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读是：<a href="https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/" target="_blank" rel="noopener">《Introduction to Concurrency in Spring Boot》</a></p>
<p>作者在文中提供了一些在 Spring Boot 中的处理多线程的实用建议，以及如何避免它可能产生的问题。</p>
<ol>
<li>Spring Boot 并发基础知识<br>在考虑Spring Boot应用程序中的并发性时，值得考虑的关键领域是：<ul>
<li>最大线程数：分配给应用处理请求的最大线程数。</li>
<li>共享外部资源：调用外部共享资源，例如数据库。</li>
<li>异步方法调用：这些方法调用在等待响应时将线程释放回线程池。</li>
<li>共享内部资源：调用内部共享资源，例如缓存和潜在的应用共享状态。</li>
</ul>
</li>
<li>Spring Boot Application 中的最大线程数<br>首先我们应该注意，正在处理的线程是有限的。<br>如果使用的是tomcat，你可以使用属性<code>server.tomcat.max-threads</code>去控制希望允许多少线程，缺省值是 0，意味着使用 Tomcat 的缺省值 200。</li>
<li>使用异步方法调用去解决共享外部资源花费大量等待时间的问题</li>
<li>在 Spring Boot 中进行异步调用<br>在主程序类中的注解 <code>@SpringApplication</code> 之上加注解<code>@EnableAsync</code>，加上之后，可以在你的 Service 方法上加 <code>@Asyn</code>，并将返回结果改为<code>CompletableFuture&lt;&gt;</code>，这样<code>@Asyn</code>的方法将后台线程池中运行，合理使用，可以降低性能损耗，提高服务效应效率。</li>
<li>控制内部资源，避免与共享相关问题的最佳建议是不要共享它们。</li>
<li>如果要共享某些状态，以下是一些建议：<ul>
<li>处理不可变的对象，如果对象是不可变的，将会避免许多并发问题。如果你需要改变一些东西，那就创建一个新的对象。</li>
<li>了解你的集合是否是线程安全的，如果需要并发访问，请使用<code>ConcurrentHashMap</code>或者其他线程安全的解决方法。</li>
<li>不要假设第三方库是线程安全的。大多数代码都不是，并且必须控制对共享状态的访问。</li>
</ul>
</li>
</ol>
<p>想要了解更多细节的小伙伴们，请点击<a href="https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/" target="_blank" rel="noopener">原文</a>，查看详情。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周分享一个在梁大的知识星球中看到的，有关 lombok 的知识点，不知道 lombok 的小伙伴们，可以查看<a href="https://zyszero.github.io/2019/03/27/ARTS002/" target="_blank" rel="noopener">ARTS 第二周分享</a>中 Tip 那小节。<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g3mtrabky2j30ku17a786.jpg" alt="lombok"></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享：<a href="https://mp.weixin.qq.com/s/LhrpypM9FKHRFlmJknBIGg" target="_blank" rel="noopener">《基于支付场景下的微服务改造与性能优化》</a>，深度好文。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/ARTS009/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/ARTS009/" itemprop="url">ARTS打卡：第九周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T23:16:09+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第九周"><a href="#ARTS打卡：第九周" class="headerlink" title="ARTS打卡：第九周"></a>ARTS打卡：第九周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="350-Intersection-of-Two-Arrays-II-Easy"><a href="#350-Intersection-of-Two-Arrays-II-Easy" class="headerlink" title="350. Intersection of Two Arrays II(Easy)"></a>350. Intersection of Two Arrays II(Easy)</h3><blockquote><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example 1:</strong></p>
<p>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2,2]</p>
<p><strong>Example 2:</strong></p>
<p>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [4,9]</p>
<p><strong>Note:</strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">leetcode.com/problems/intersection-of-two-arrays-ii</a></cite></footer></blockquote>
<p>大致题意：</p>
<p>给两个数组，写一个方法计算它们的交集。<br><strong>注意：</strong></p>
<ol>
<li>结果中的每个元素应该出现在两个数组中显示的次数。</li>
<li>结果可以是任何顺序。</li>
</ol>
<p>解题思路1：<br>假设输入的数组为 a、b，输出的数组为 r</p>
<ol>
<li>对a、b进行排序</li>
<li>假设 i 为 a 的起始下标 0，j 为 b 的起始下标 0，k 为结果集的起始下标，从 0 开始</li>
<li>遍历数组，比较 a[i] 和 b[j]，如果 a[i] &lt; b[j]，移动下标 i，即 i++；如果 a[i] &gt; b[j]，移动下标 j，即 j++；如果 a[i] = b[j]，使得 r[k] = b[j]，且同时往前移动三个数组的下标。</li>
<li>以此类推，直至 i 等于数组a的长度且 j 等于数组b的长度，终止循环，数组 r 就是结果</li>
<li>输出数组 r 可以为 数组 a</li>
</ol>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; results = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 1. 先排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(nums1, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 1 ms, faster than 100.00% of Java online submissions for Intersection of Two Arrays II.<br>Memory Usage: 35.5 MB, less than 73.31% of Java online submissions for Intersection of Two Arrays II.</p>
<p>复杂度分析：<br>时间复杂度：O(n)。Array.sort() 时间复杂度是 O(nlogn)，遍历是 O(n)，时间复杂度主要取决于遍历。<br>空间复杂度：O(k)。</p>
<p>解题思路2：<br>因为题目对结果的顺序没有要求，所以我们可以借助 map 来实现。</p>
<ol>
<li>假设输入的数组为：数组a和数组b，i，j分别为数组a、b的下标；</li>
<li>借助一个容器 map，key 为数组的值，value 为值出现的次数和用一个 list 存储结果</li>
<li>遍历数组a，判断 map 的 key 集合中是否有 a[i]，有，则 value + 1，无，则把这个值加入到map中</li>
<li>遍历数组b，判断 map 的 key 集合中是否有 b[j]，且对应的value 是否大于 0，若是，将 b[j] 加入到结果 list 中，并将 value 减一。</li>
<li>遍历结束，将list转为数组，输出结果。</li>
</ol>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;(<span class="number">16</span>);</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">        <span class="comment">// 判断 map 的 key 集合中是否有 a[i]，有，则 value + 1，无，则把这个值加入到map中</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">            map.put(i, (<span class="keyword">int</span>) map.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以换成 java 8 的写法</span></span><br><span class="line">        <span class="comment">//map.put(nums1[i], (int) map.getOrDefault(nums1[i], 0) + 1);</span></span><br><span class="line">        <span class="comment">// 或</span></span><br><span class="line">        <span class="comment">//map.merge(nums1[i], 1, (a, b) -&gt; (int) a + (int) b);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">    <span class="comment">//判断 map 的 key 集合中是否有 b[j]，且对应的value 是否大于 0，若是，将 b[j] 加入到结果 list 中，并将 value 减一</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(i) &amp;&amp; (<span class="keyword">int</span>) map.get(i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(i);</span><br><span class="line">            map.put(i, (<span class="keyword">int</span>) map.get(i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">        r[i] = result.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 3 ms, faster than 54.64% of Java online submissions for Intersection of Two Arrays II.<br>Memory Usage: 35.7 MB, less than 66.55% of Java online submissions for Intersection of Two Arrays II.</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>这周分享：<a href="https://www.e4developer.com/2018/08/06/spring-boot-best-practices/#more-2109" target="_blank" rel="noopener">《Spring Boot – Best Practices》</a><br>作者在文中结合了自己的工作经验和其他springboot专家著作，给出了如下15条实践建议：</p>
<ol>
<li>使用自动配置</li>
<li>使用Spring Initializr来开始一个新的Spring Boot项目</li>
<li>考虑为常见的组织问题创建自己的自动配置</li>
<li>正确设计你的代码目录结构</li>
<li>保持你的 @Controller 的整洁和专一</li>
<li>围绕业务功能来构建你的 @Service</li>
<li>使数据库独立于核心业务逻辑之外</li>
<li>保持核心业务逻辑独立于 spring boot</li>
<li>推荐使用构造函数</li>
<li>熟悉并发模型</li>
<li>加强配置管理的外部化</li>
<li>提供全局异常处理</li>
<li>使用日志框架</li>
<li>测试你的代码</li>
<li>使用切片测试，让测试更容易，更专注</li>
</ol>
<p>感兴趣的小伙伴们，可以点击原文，查看更多的详情~</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>这周分享一个在工作上用到的抓包工具：Wireshark，可以直接在网上下载，是个免费软件。<br>下载地址：<a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener">https://www.wireshark.org/download.html</a><br>使用方法可以直接 google 或者度娘又或者看我在 Share 章节分享的笔记。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享：<a href="http://note.youdao.com/noteshare?id=9027a956b30d59a71eaa83a22b9f1134&amp;sub=2E3FC528AA74419F81663071028B3890" target="_blank" rel="noopener">Wireshark使用详解以及HTTP抓包。</a></p>
<p>该笔记部分内容是我结合网上许多资料而来的，记录时间比较久远了，已经不清楚是从哪几篇文章上摘抄下来的了，如有侵权，联系删除。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/ARTS008/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/ARTS008/" itemprop="url">ARTS打卡：第八周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T17:02:05+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第八周"><a href="#ARTS打卡：第八周" class="headerlink" title="ARTS打卡：第八周"></a>ARTS打卡：第八周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="136-Single-Number（Easy）"><a href="#136-Single-Number（Easy）" class="headerlink" title="136. Single Number（Easy）"></a>136. Single Number（Easy）</h3><blockquote><p>Given a <strong>non-empty</strong> array of integers, every element appears twice except for one. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<p>Input: [2,2,1]<br>Output: 1</p>
<p><strong>Example 2:</strong></p>
<p>Input: [4,1,2,1,2]<br>Output: 4</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">leetcode.com/problems/single-number</a></cite></footer></blockquote>
<p><strong>题意：</strong><br>给一个不空的整型数组，除一个元素之外，其余每个元素都会出现两次，找到那个独立的元素。<br><strong>注意：</strong>你的算法应该具有线性运行时复杂度。你能不用额外的内存来实现它吗？</p>
<p><strong>解题思路1：</strong><br>根据题意，我们可以知道，输入是一个不为空的整型数组，且这个数组长度一定是奇数的，且那个不重复的元素一定是奇数位的元素，那么我们可以先对数组进行排序，然后遍历数组，假设这个数组为 nums，当 nums[i] != nums[i + 1] &amp;&amp; nums[i] != nums[i - 1] 时，nums[i] 即为那个不重复的元素，当然首尾元素要单独进行判断。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i != nums.length - <span class="number">1</span> &amp;&amp; nums[i] != nums[i + <span class="number">1</span>] &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br>Runtime: 3 ms, faster than 42.26% of Java online submissions for Single Number.<br>Memory Usage: 37.9 MB, less than 77.61% of Java online submissions for Single Number.</p>
<p><strong>解题思路2：</strong><br>还有一种解算，我在讨论区看到的，着实让我眼前一亮，从而打开了新世界的大门。<br>利用 XOR 逻辑异或去做，因为 0 ^ N = N，N ^ N = 0，所以只需以0为初始值，去遍历数组，进行异或运算，最后就能得到那个唯一的不同值。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哇，这个解法完全没想到，打开新世界的大门</span></span><br><span class="line"><span class="comment">     * 使用 XOR 逻辑异或 去做</span></span><br><span class="line"><span class="comment">     * 0 ^ N = N</span></span><br><span class="line"><span class="comment">     * N ^ N = 0</span></span><br><span class="line"><span class="comment">     * 所以只需遍历进行异或，就能得到那个唯一的不同值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            a ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Single Number.<br>Memory Usage: 38.2 MB, less than 73.27% of Java online submissions for Single Number.</p>
<p><strong>时间复杂度：</strong><code>O(n)</code><br><strong>空间复杂度：</strong><code>O(1)</code></p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周分享一篇在 Medium 上看到的文章：<a href="https://hackernoon.com/what-i-learned-from-doing-1000-code-reviews-fe28d4d11c71" target="_blank" rel="noopener">《What I learned from doing 1000 code reviews》</a>。<br>作者在这篇文章中，分享了自己在 LinkedIn 工作期间，进行大量代码审查后得出 <code>code review</code> 的四点建议：</p>
<ol>
<li><p>当出现问题时，要抛出异常。</p>
</li>
<li><p>尽可能使用最具体的类型。</p>
</li>
<li><p>使用 Optional 代替 nulls。</p>
</li>
<li><p>尽可能使用 “Unlift” 方法。</p>
</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周分享一个 IDEA 的插件：Sequence Diagram。<br>安装步骤：Setting(Ctrl + Shift + s)-&gt;Plugins-&gt;Marketplace，在插件商店直接搜索 SequenceDiagram，然后安装插件，重启 IDEA。<br>效果如下：</p>
<p>鼠标右键点击，选择 Sequence Diagram<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g35umgqp8wj309l0j5aan.jpg" alt="Sequence Diagram"></p>
<p>就可以看到自动生成的时序图了<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g35uo4flqbj30gi0mhwev.jpg" alt="时序图"></p>
<p>更多详情，可以查看 SequenceDiagram 的官网：<a href="http://vanco.github.io/SequencePlugin/" target="_blank" rel="noopener">SequencePlugin</a>。</p>
<p>如果无法通过插件商店下载，可以在这里<a href="https://plugins.jetbrains.com/plugin/8286-sequencediagram" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8286-sequencediagram</a>手动下载，然后自行安装。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>这周分享一篇梁大的文章：<a href="https://mp.weixin.qq.com/s/tP6Afu9q39RuJaAhN6_Ajw" target="_blank" rel="noopener">《人人都是 API 设计者：我对 RESTful API、GraphQL、RPC API 的思考》</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/ARTS007/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/ARTS007/" itemprop="url">ARTS打卡：第七周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T15:30:53+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第七周"><a href="#ARTS打卡：第七周" class="headerlink" title="ARTS打卡：第七周"></a>ARTS打卡：第七周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="189-Rotate-Array-Easy"><a href="#189-Rotate-Array-Easy" class="headerlink" title="189. Rotate Array(Easy)"></a>189. Rotate Array(Easy)</h3><blockquote><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p><strong>Example 1:</strong></p>
<p>Input: [1,2,3,4,5,6,7] and k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p>
<p><strong>Example 2:</strong></p>
<p>Input: [-1,-100,3,99] and k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p>
<p>Note:</p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">leetcode.com/problems/rotate-array</a></cite></footer></blockquote>
<p>题意：<br>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>需要注意是只允许使用 O(1)的额外空间，效果如 Example 所示。</p>
<p>解题思路1：使用暴力破解。<br>循环 K 次，每次遍历数组，让数组的每一位元素往前移动一位。</p>
<p>解题代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            nums[j] = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度分析：O(k * n)<br>空间复杂度分析：O(1)</p>
<p>解题思路2：<br>仔细观察 Example ，我们可以发现一个事实，旋转数组 K 次，K 个元素从数组后端挪动到前端，其余元素从前端挪到后端。<br>在这种方法中，我们首先翻转数组，然后再次翻转数组前 k 个元素，最后翻转 n - k 个元素，即其余的元素，n 为数组长度；这样就能得出答案。<br>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                           : <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">首先翻转整个数组                    : <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">其次翻转数组前 k 个元素             : <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">最后翻转数组后 n - k 个元素         :<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt; Result</span><br></pre></td></tr></table></figure>
<p>解题代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    <span class="comment">// 翻转整个数组</span></span><br><span class="line">    reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 翻转数组前 k 个元素</span></span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 翻转数组后 n - k 个元素</span></span><br><span class="line">    reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="217-Contains-Duplicate-Easy"><a href="#217-Contains-Duplicate-Easy" class="headerlink" title="217. Contains Duplicate(Easy)"></a>217. Contains Duplicate(Easy)</h3><blockquote><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<p>Input: [1,2,3,1]<br>Output: true</p>
<p><strong>Example 2:</strong></p>
<p>Input: [1,2,3,4]<br>Output: false</p>
<p><strong>Example 3:</strong></p>
<p>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">leetcode.com/problems/contains-duplicate</a></cite></footer></blockquote>
<p>题意：<br>给一个 int 类型的数组，如果数组内有重复的元素，返回 true，无则返回 false。</p>
<p>思路1：结合set集合进行判重。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：<br>时间复杂度：O(n)，set的查找和插入消耗的时间都是常量。<br>空间复杂度：O(n)，额外消耗的空间就是set的大小，取决于有多少元素加入到集合中。</p>
<p>思路2：先对数组进行排序，然后遍历进行判重。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：<br>时间复杂度：O(nlogn)。Array.sort() 时间复杂度是 O(nlogn)，遍历是 O(n)，不过遍历的次数是基于排序的情况来决定的，所以时间复杂度是 O(nlogn)。<br>空间复杂度：O(1)。空间复杂度取决于 Arrays.sort()的内部实现，如果是使用heapsort，通常会花费 O(1) 的辅助空间。</p>
<p>思路3：利用 Java 8 的 distinct() 和 count() 来做。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = Arrays.stream(nums).distinct().count();</span><br><span class="line">    <span class="keyword">return</span> nums.length == count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法从 leetcode 给出结果上来看，消耗时间最长，空间消耗也最大，时间和空间的复杂度不知如何分析<em>(:з」∠)</em>，不过代码更简洁易懂。</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html" target="_blank" rel="noopener">《UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking 》中的 6.2 I/O Models</a>。</p>
<p>作者 Stevens 在这节中详细说明了五种 IO Model 的特点和区别。</p>
<p>这五种 IO Model 分别是：BIO（blocking IO）、NIO（non-blocking IO）、 IO multiplexing、signal driven IO 和 AIO（asynchronous IO）。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>分享一篇我在学习《左耳听风》专栏做的笔记，有关于如何高效学习的：<a href="http://note.youdao.com/noteshare?id=e2c88611b709945c2c80fb23dd262b88&amp;sub=5C2758140DF44ED69E66909F9B9E1A1A" target="_blank" rel="noopener">97 - 高效学习：深度，归纳和坚持实践</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享梁大组织维护的一个知识仓库：<a href="https://www.yuque.com/server_mind/answer" target="_blank" rel="noopener">服务端思维</a>，里面有每周答疑周报、每月精读等内容，非常值得小伙伴们关注~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/ARTS006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/ARTS006/" itemprop="url">ARTS打卡：第六周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-28T21:42:20+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第六周"><a href="#ARTS打卡：第六周" class="headerlink" title="ARTS打卡：第六周"></a>ARTS打卡：第六周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>这周的 LeetCode 记录如下：</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array（Easy）"><a href="#26-Remove-Duplicates-from-Sorted-Array（Easy）" class="headerlink" title="26. Remove Duplicates from Sorted Array（Easy）"></a>26. Remove Duplicates from Sorted Array（Easy）</h3><blockquote><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<p>Given nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
<p><strong>Example 2:</strong></p>
<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<p>// nums is passed in by reference. (i.e., without making a copy)<br>int len = removeDuplicates(nums);</p>
<p>// any modification to nums in your function would be known by the caller.<br>// using the length returned by your function, it prints the first len elements.<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">leetcode.com/problems/remove-duplicates-from-sorted-array</a></cite></footer></blockquote>
<p>大致题意：<br>删除排序数组中的重复项，要求给定一个排序数组，在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>解题思路：<br>这道题，我们可以借鉴快慢指针的思想来做，不过不是用链表，是用数组进行模拟：<br>假设 slow 为慢指针，fast 为快指针，因为 nums 数组是已经排好序的升序数组，所以当 nums[slow] = nums[fast]，我们让快指针前进一步，跳过重复的数据，即 fast++；若 nums[slow] != nums[fast]时，让慢指针前进一步，即 slow++，然后交换快指针与慢指针的值，将新数据替换掉重复数据，即 nums[slow] = nums[fast]；重复步骤直至快指针走到数组尾部，即 fast == nums.length时，输出结果 slow + 1，这就是去重后的数组长度了。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当是空数组时，直接返回 0，边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow 为慢指针</span></span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fast 为 快指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">1</span>; fast &lt; nums.length; fast++</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>运行结果：<br>Runtime: 1 ms, faster than 99.98% of Java online submissions for Remove Duplicates from Sorted Array.<br>Memory Usage: 40.8 MB, less than 84.56% of Java online submissions for Remove Duplicates from Sorted Array.</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II(Easy)"></a>122. Best Time to Buy and Sell Stock II(Easy)</h3><blockquote><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<p>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<p><strong>Example 2:</strong></p>
<p>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation:<br>Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>engaging multiple transactions at the same time. You must sell before buying again.</p>
<p><strong>Example 3:</strong><br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-ii</a></cite></footer></blockquote>
<p>题意：<br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br><strong>注意：</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>解题思路：<br>这道题是看答案才明白过来的，感觉挺有趣的，虽然挺多人认为这道题就是拿来搞笑的。<br>有三种解决方法，详情请查看：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/</a><br>第三种解法，着实我眼前一亮。<br>先暂时忽略题目的限制，那么我们就可以得出这个结果：只要我们每次买进股票的价格比我们卖出的价格低的机会，就能实现利润最大化。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i - <span class="number">1</span>] &lt; prices[i]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是这篇文章：<a href="https://www.usenix.org/legacy/event/usenix04/tech/general/full_papers/elmeleegy/elmeleegy_html/html.html" target="_blank" rel="noopener">Lazy Asynchronous I/O For Event-Driven Servers</a></p>
<p>文中详细介绍了LAIO的概念，LAIO 的 API，并将其与 NIO、AIO 进行了多方面多角度的比较。</p>
<p>部分笔记如下图所示：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g2o6zi8io3j31qq1swasb.jpg" alt="LAIO"></p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>这周 VS Code 用的比较多，就分享下快捷键的使用吧。</p>
<p><code>windows</code> 版的快捷键说明文档，可以直接通过快捷键 <code>Ctrl + K，Ctrl + R</code> 获取，也可以通过这个网址获取：<a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" target="_blank" rel="noopener">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a></p>
<p>中文版的可以参看这个博客：<a href="https://blog.csdn.net/crper/article/details/54099319" target="_blank" rel="noopener">VS Code折腾记 - (2) 快捷键大全，没有更全</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享：<a href="https://mp.weixin.qq.com/s/LN8UlS5OBhl9gIIkSE2erQ" target="_blank" rel="noopener">一个NullPointerException，竟然有这么多花样！</a></p>
<p>文章来自肥朝大佬的公众号，文风一如既往的幽默风趣，知识点讲解条理清晰。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/ARTS005/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/ARTS005/" itemprop="url">ARTS打卡：第五周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-20T15:53:22+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第五周"><a href="#ARTS打卡：第五周" class="headerlink" title="ARTS打卡：第五周"></a>ARTS打卡：第五周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>这周将 Recursion I 剩余部分完成了，记录如下：</p>
<h3 id="96-Unique-Binary-Search-Trees-Medium"><a href="#96-Unique-Binary-Search-Trees-Medium" class="headerlink" title="96. Unique Binary Search Trees(Medium)"></a>96. Unique Binary Search Trees(Medium)</h3><blockquote><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p>
<p><strong>Example:</strong></p>
<p>Input: 3<br>Output: 5<br>Explanation:<br>Given n = 3, there are a total of 5 unique BST’s:</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">leetcode.com/problems/unique-binary-search-trees</a></cite></footer></blockquote>
<p>题目意思：给定n值，求出有多少结构上唯一的存储值1 … n的BST（二叉搜索树）？</p>
<p>首先我们要了解二叉搜索树（BST binary search trees）是什么?</p>
<blockquote><p>二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ol>
<footer><strong>@DevDocs</strong><cite><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9</a></cite></footer></blockquote>
<p>思路来源：<br><a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n" target="_blank" rel="noopener">DP Solution in 6 lines with explanation. F(i, n) = G(i-1) * G(n-i)</a>-G(i-1)-*-G(n-i))</p>
<p>这个帖子说的很详细，建议小伙伴们都看看。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了方便理解，申请长度为 n+1 的数组，便于最后直接返回 g[n]</span></span><br><span class="line">        <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        g[<span class="number">0</span>] = g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从g(2)出发</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// g(n) = f(1, n) + ... + f(n, n)</span></span><br><span class="line">                <span class="comment">// f(i, n) = g(i -1) * g(n - i)</span></span><br><span class="line">                <span class="comment">// g(n) = g(0) * g(n - 1) + ... + g(n - 1) * g(0)</span></span><br><span class="line">                g[i] += g[j -<span class="number">1</span>] * g[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II(Medium)"></a>95. Unique Binary Search Trees II(Medium)</h3><blockquote><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p>
<p><strong>Example:</strong></p>
<p>Input: 3<br>Output:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>Explanation:<br>The above output corresponds to the 5 unique BST’s shown below:</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">leetcode.com/problems/unique-binary-search-trees</a></cite></footer></blockquote>
<p>题目意思：给定整数n，生成存储值1 … n的所有结构上唯一的BST（二叉搜索树）。</p>
<p>思路：<br>其实跟上面那道题的思路很相像，这里大致说下：</p>
<ol>
<li>我们从 Example 可得出如果 n 是输入值的话，那么根节点可能就是 1-n 中任何一个。</li>
<li>我们可以先假设 G(n) = G(start, end) 能获取生成存储值1 … n的所有结构上唯一的BST，start是 1-n 范围内的起点，end 是终点，即 n。</li>
<li>因为是BST，所以当i为根节点时，左子树的所有结果集可以假设为 G(start, i - 1)，，右子树的所有结果集可以假设为 G(i+1, n)。</li>
<li>确认 base case，能确认最底部的根节点，然后关联有可能的左子树和右子树，最后返回一个包含了所有的情况的集合，当 start &gt; end 的时候，返回一个空集合，表示没有左/右子树。</li>
<li>确认边界条件，当 n == 0，直接返回空集合。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> genTrees(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; treeNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//  base case</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        treeNodes.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> treeNodes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; leftTreeNodes, rightTreeNodes;</span><br><span class="line">        <span class="comment">// 获取左子树的所有可能-递归公式</span></span><br><span class="line">        leftTreeNodes = genTrees(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取右子树的所有可能-递归公式</span></span><br><span class="line">        rightTreeNodes = genTrees(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode leftTreeNode :</span><br><span class="line">                leftTreeNodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode rightTreeNode :</span><br><span class="line">                    rightTreeNodes) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                root.left = leftTreeNode;</span><br><span class="line">                root.right = rightTreeNode;</span><br><span class="line">                treeNodes.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是：<a href="https://www.codechef.com/wiki/tutorial-dynamic-programming#" target="_blank" rel="noopener">Tutorial For Dynamic Programming</a></p>
<p>是一篇很好的动态规划的学习资料。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>这周分享从梁大的知识星球中学到的 tip：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g2992ekt12j30ku1gcdqj.jpg" alt="优雅退出服务小结"></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享的是小灰大大的文章：<a href="https://zhuanlan.zhihu.com/p/31628866" target="_blank" rel="noopener">漫画：什么是动态规划？</a></p>
<p>这篇文章以漫画的形式，生动形象的介绍了动态规划，让算法学起来不再那么的枯燥无味。</p>
<p>小灰的公众号还有其他以漫画形式介绍算法的文章，感兴趣的小伙伴们可以关注走一波。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/ARTS004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/ARTS004/" itemprop="url">ARTS打卡：第四周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T15:20:18+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第四周"><a href="#ARTS打卡：第四周" class="headerlink" title="ARTS打卡：第四周"></a>ARTS打卡：第四周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周记录如下：</p>
<h3 id="104-Maximum-Depth-of-Binary-Tree（Easy）"><a href="#104-Maximum-Depth-of-Binary-Tree（Easy）" class="headerlink" title="104. Maximum Depth of Binary Tree（Easy）"></a>104. Maximum Depth of Binary Tree（Easy）</h3><blockquote><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
undefined
<p>return its depth = 3.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">leetcode.com/problems/maximum-depth-of-binary-tree</a></cite></footer></blockquote>
<p>题目大致意思：<br>给一个二叉树，找到它的最大深度，最大深度是指从根节点到最远叶节点的最长路径上的节点数。</p>
<p>思路：使用DFS（深度优先遍历）</p>
<p>解法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root == null 时返回 0，是边界条件</span></span><br><span class="line">        <span class="comment">// root != null 时，必有一个节点</span></span><br><span class="line">        <span class="comment">// 假设 maxDepth(root.left) 能求出左子树的最大深度，maxDepth(root.right) 能求出右子树的最大深度，那么只需比较左右子树的最大深度，取max，再加上根节点的 1，就是二叉树的最大深度了</span></span><br><span class="line">        <span class="comment">// 其实就是利用深度优先遍历求最大深度</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录最大深度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         dsf(root, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dsf</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当前 root 为 null 时，要么根结点为 null，那么已经到达底部</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 每次达到底部时，比较当前深度和当前记录的最大深度，取两者最大值</span></span><br><span class="line">            max = Math.max(max, depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 深度 + 1</span></span><br><span class="line">        depth++;</span><br><span class="line"></span><br><span class="line">        dsf(root.left, depth);</span><br><span class="line">        dsf(root.right, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-Merge-Two-Sorted-Lists（Easy）"><a href="#21-Merge-Two-Sorted-Lists（Easy）" class="headerlink" title="21. Merge Two Sorted Lists（Easy）"></a>21. Merge Two Sorted Lists（Easy）</h3><blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">leetcode.com/problems/merge-two-sorted-lists</a></cite></footer></blockquote>
<p>题目：<br>合并两个已排序的链表，并将其作为一个新列表返回。新列表应该通过将前两个列表的节点拼接在一起来创建。</p>
<p>思路：<br>需要正确理解题意，这道题给出的例子，其实很容易误导做题者，一开始我就被误导了，直至后面才发现，这道题要的新列表是要有序。</p>
<p>我们可以用递归来解这道题，解决递归的流程一般有四步：</p>
<ol>
<li>定义一个递归方法</li>
<li>推导出递归方法和基本情况（base case）</li>
<li>如果递归方法存在重复计算的问题，使用记忆化技术进行优化</li>
<li>尽可能的使用尾递归</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1.val &gt; l2.val)&#123;</span><br><span class="line">        <span class="comment">// 当 l1 的值大于 l2 时，将 l2 当做头结点，并将头结点的下一个后继节点指向 mergeTwoLists 方法返回的节点</span></span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="comment">// 返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Two Sorted Lists.<br>Memory Usage: 37 MB, less than 97.90% of Java online submissions for Merge Two Sorted Lists.</p>
<h3 id="779-K-th-Symbol-in-Grammar（Medium）"><a href="#779-K-th-Symbol-in-Grammar（Medium）" class="headerlink" title="779. K-th Symbol in Grammar（Medium）"></a>779. K-th Symbol in Grammar（Medium）</h3><blockquote><p>On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.</p>
<p>Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).</p>
<p><strong>Examples:</strong><br>Input: N = 1, K = 1<br>Output: 0</p>
<p>Input: N = 2, K = 1<br>Output: 0</p>
<p>Input: N = 2, K = 2<br>Output: 1</p>
<p>Input: N = 4, K = 5<br>Output: 1</p>
<p>Explanation:<br>row 1: 0<br>row 2: 01<br>row 3: 0110<br>row 4: 01101001</p>
<p><strong>Note:</strong></p>
<p>N will be an integer in the range [1, 30].<br>K will be an integer in the range [1, 2^(N-1)].</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">leetcode.com/problems/k-th-symbol-in-grammar</a></cite></footer></blockquote>
<p>题目：</p>
<p>在第一行，我们写一个0。现在，在后面的每一行中，查看前面一行，并将每个出现的0替换为01，将每个出现的1替换为10。给定第N行和索引K，返回第N行中的第K个索引符号(K的值为1个索引)(1个索引)。</p>
<p>解题思路：</p>
<p>从 Example 中，我们可以得出一个规律：</p>
<p>假设 row(N) 表示第 N 行，currLen 表示当前行的长度，preLen 表示上一行的长度，row(N)[K] 表示第 N 行，下标为 k 的值。</p>
<p>当 K 值小于等于 currLen/2，即 row(N-1) 的长度时，row(N)[K] 等于 row(N-1)[k]，  当 K 值大于 currLen/2 时，row(N)[K] 等于 row(N-1)[K - preLen] 与 1 的异或值。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以已有的条件可得</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前 N 行的长度</span></span><br><span class="line">    <span class="keyword">int</span> currMaxLength = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, N-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 当前 N 行的一半长度，即上一行的长度</span></span><br><span class="line">    <span class="keyword">int</span> midLength = currMaxLength / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 当 K 值小于等于 currLen/2，即 row(N-1) 的长度时，row(N)[K] 等于 row(N-1)[k]</span></span><br><span class="line">    <span class="keyword">if</span> (K &lt;= midLength)&#123;</span><br><span class="line">        <span class="keyword">return</span> kthGrammar(N - <span class="number">1</span>, K);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//  当 K 值大于 currLen/2 时，row(N)[K] 等于 row(N-1)[K - preLen] 与 1 的异或值</span></span><br><span class="line">        <span class="keyword">return</span> kthGrammar(N-<span class="number">1</span>, K- midLength) ^ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是以下三篇文章，都是与异步 I/O 模型有关的：</p>
<ol>
<li><a href="https://www.slideshare.net/e456/tyma-paulmultithreaded1" target="_blank" rel="noopener">Thousands of Threads and Blocking l/O:The Old Way to Write Java Servers Is New Again（and Way Better）</a></li>
<li><a href="http://116.199.9.132:83/2Q2WEFD048125304E64CA8C982B0A997B2574B94E071_unknown_A75C52C9971B3CB616973B1E53478BF698F0BE07_6/gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Scalable IO in Java</a></li>
<li><a href="https://developer.ibm.com/articles/l-async/" target="_blank" rel="noopener">Boost application performance using asynchronous I/O</a></li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>感觉这周没学到什么小技巧Orz，就分享一个小发现吧，IDEA 自带的一个功能， View -&gt; Show ByteCode，效果如下：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g226mh3ynkj313t0m076j.jpg" alt="View -&gt; Show ByteCode"></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享知秋大佬的有关 NIO 的系列文章：</p>
<ul>
<li><a href="https://juejin.im/post/5c2cc075f265da611037298e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之BIO</a></li>
<li><a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></li>
<li><a href="https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 中</a></li>
<li><a href="https://juejin.im/post/5c3a01d851882525c55fad36" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 之 Selector</a></li>
<li><a href="https://juejin.im/post/5c4738c151882525c638144e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 Buffer解读 上</a></li>
<li><a href="https://juejin.im/post/5c653140518825625e4abfc6" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 Buffer解读 下</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/06/ARTS003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/06/ARTS003/" itemprop="url">ARTS打卡：第三周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T15:53:32+08:00">
                2019-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第三周"><a href="#ARTS打卡：第三周" class="headerlink" title="ARTS打卡：第三周"></a>ARTS打卡：第三周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周记录如下：</p>
<h3 id="206-Reverse-Linked-List（Easy）"><a href="#206-Reverse-Linked-List（Easy）" class="headerlink" title="206. Reverse Linked List（Easy）"></a>206. Reverse Linked List（Easy）</h3><blockquote><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong><br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode.com/problems/reverse-linked-list</a></cite></footer></blockquote>
<p>题目：反转单链表，示例如上所示。</p>
<p>思路1： 首先让单链表的头结点的前驱节点指向NULL，然后遍历链表节点，改变当前节点的后继节点为前驱节点，直至循环结束，返回尾结点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录上一个节点（一开始为null，是为了让单链表的头结点的前驱节点指向NULL）</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// 循环遍历至尾结点</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 临时节点，保存当前节点的后继节点</span></span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        <span class="comment">// 改变当前节点的后继节点为前驱节点</span></span><br><span class="line">        curr.next = prev;</span><br><span class="line">        <span class="comment">// 移动节点</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回旧单链表的尾结点（即反转后的新单链表的头结点）</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.<br>Memory Usage: 37.7 MB, less than 29.48% of Java online submissions for Reverse Linked List.</p>
<p>思路2：<br>使用递归，来自官方的解法：</p>
<blockquote><p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let’s assume the list is: n1 → … → nk-1 → nk → nk+1 → … → nm → Ø</p>
<p>Assume from node nk+1 to nm had been reversed and you are at node nk.</p>
<p>n1 → … → nk-1 → nk → nk+1 ← … ← nm</p>
<p>We want nk+1’s next node to point to nk.</p>
<p>So,</p>
<p>nk.next.next = nk;</p>
<p>Be very careful that n1’s next must point to Ø. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p>
</blockquote>
<p>大致意思：</p>
<p>我们可以假设单链表是这样的：n1 → … → nk-1 → nk → nk+1 ← … ← nm，现在想要 nk+1 的后继节点指向nk，即 （nk+1.next = nk）。</p>
<p>所以我们的 Base Case 是： nk.next.next = nk。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当头结点为 null，直接返回 null（边界条件）</span></span><br><span class="line">    <span class="comment">// head.next == null，递归终止的条件 </span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前节点的后继节点，即 nk+1</span></span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">// 因为 n1 的前驱节点要指向 null</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.<br>Memory Usage: 37.7 MB, less than 41.78% of Java online submissions for Reverse Linked List.</p>
<h3 id="509-Fibonacci-Number（Easy）"><a href="#509-Fibonacci-Number（Easy）" class="headerlink" title="509. Fibonacci Number（Easy）"></a>509. Fibonacci Number（Easy）</h3><blockquote><p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</p>
<p>Given N, calculate F(N).</p>
<p><strong>Example 1:</strong></p>
<p>Input: 2<br>Output: 1<br>Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</p>
<p><strong>Example 2:</strong></p>
<p>Input: 3<br>Output: 2<br>Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</p>
<p><strong>Example 3:</strong></p>
<p>Input: 4<br>Output: 3<br>Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</p>
<p><strong>Note:</strong></p>
<p>0 ≤ N ≤ 30.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">leetcode.com/problems/fibonacci-number</a></cite></footer></blockquote>
<p>题目：<br>斐波纳契数，哈哈哈，大家是不是很眼熟呐，一道很经典的题目，这里不解释题目意思了。</p>
<p>解题思路：<br>这里先要引入一个概念，Memoization（记忆化）。</p>
<blockquote>
<p>Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. (Source: wikipedia)</p>
</blockquote>
<p>简单来说，记忆化技术是用来解决递归方法中出现重复计算的问题，使用缓存保存之前计算过的结果，使得相同输入，无需重复计算，直接从缓存中获取值。</p>
<p>在这道题中，我们可以看出，有很多次的重复计算，比如：F(4) = F(3) + F(2) = F(2) + F(2) + F(1) = F(1) + F(0) + F(1) + F(0) + F(1)。</p>
<p>所以我们可以引入记忆化技术。从上述的例子中，可以推导出递归公式为：F(n) = F(n-1) + F(n-2)。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个map集合，作为缓存</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断输入的值 N ，在缓存中是否存在计算结果，有的话直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cacheMap.containsKey(N))&#123;</span><br><span class="line">            <span class="keyword">return</span> cacheMap.get(N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="comment">// F(1) = 1, F(0) = 0，所以当 N &lt; 2 时，可以直接返回 N 。</span></span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            result =  N;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把计算结果放到缓存中</span></span><br><span class="line">        cacheMap.put(N, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Fibonacci Number.<br>Memory Usage: 31.7 MB, less than 100.00% of Java online submissions for Fibonacci Number.</p>
<p>我在 submissions 中发现一个有趣的答案，使用 Java 8 特性解题的，分享给大家：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// F(1) = 1, F(0) = 0，所以当 N &lt; 2 时，可以直接返回 N 。</span></span><br><span class="line">        <span class="keyword">if</span> ( N == <span class="number">0</span> || N == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// .limit(N + 1)： 循环 N + 1 次，每次生成一个数组为[f[1], f[0]+f[1]]，f 为上一个数组，new int[]&#123;0, 1&#125;为初始值，.mapToInt(f -&gt; f[0])：获取每个数组的f[0]，形成IntStream；.max()：获取流中数值最大的元素，.getAsInt()： 转成 int 数值。</span></span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, f -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;f[<span class="number">1</span>], f[<span class="number">0</span>] + f[<span class="number">1</span>]&#125;)</span><br><span class="line">                .limit(N + <span class="number">1</span>)</span><br><span class="line">                .mapToInt(f -&gt; f[<span class="number">0</span>])</span><br><span class="line">                .max()</span><br><span class="line">                .getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算结果：<br>Runtime: 38 ms, faster than 5.57% of Java online submissions for Fibonacci Number.<br>Memory Usage: 32.3 MB, less than 100.00% of Java online submissions for Fibonacci </p>
<h3 id="70-Climbing-Stairs-Easy"><a href="#70-Climbing-Stairs-Easy" class="headerlink" title="70. Climbing Stairs(Easy)"></a>70. Climbing Stairs(Easy)</h3><blockquote><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
undefined
<p><strong>Example 2:</strong></p>
undefined
</blockquote>
<p>题目大致意思：<br>你正在爬楼梯，需要n步才能达到楼顶。 每次你可以爬1或2步。那可以通过多少不同的方式登顶？ 注意：给定n将是一个正整数。</p>
<p>核心思路：<br>把握一个核心思想，就是达到楼顶的最后步数，要么是1，要么是2。<br>我们假设当 n = 4 时， 可能的方式为 F(3) + 1 或者 F(2) + 2，即 F(4) = F(3) + F(2)，所以我们可以推导出公式为：F(n) = F(n-1) + F(n -2)。</p>
<p>解法一：递归 + 记忆化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缓存数组，用于存储F(n)的值，下标对应 n 值。</span></span><br><span class="line">        <span class="keyword">int</span> memo[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> climb_Stairs(<span class="number">0</span>, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climb_Stairs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> memo[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = climb_Stairs(i + <span class="number">1</span>, n, memo) + climb_Stairs(i + <span class="number">2</span>, n, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>解法二：动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 n+1 的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 有0下标的值，是为方便F(2)的计算</span></span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    result[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环 n 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 根据 f(i -1) 和 f(i -2) 的值动态计算 f(i)的值</span></span><br><span class="line">        result[i] = result[i -<span class="number">1</span>] + result[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>解法三：Fibonacci Number<br>不知你们发现没，这题跟我们上一题斐波纳契数是一样，都是F(n) = F(n-1) + F(n-2)，代码跟解法二基本一样，只是数组换成了整形，在空间消耗上进行了优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>LeetCode上还有几种解法，在时间复杂度上有了进一步的优化，感兴趣的小伙伴们，可以自行查看：<a href="https://leetcode.com/problems/climbing-stairs/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/solution/</a></p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是 LeetCode Recursion I 上的三篇文章：<a href="https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/1669/" target="_blank" rel="noopener">Time Complexity - Recursion</a> 、 <a href="https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/1671/" target="_blank" rel="noopener">Space Complexity - Recursion</a> 和 <a href="https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/2374/" target="_blank" rel="noopener">Tail Recursion</a>。</p>
<p>《Time Complexity - Recursion》，作者在这篇文章中介绍了如何对递归方法的时间复杂度进行分析。文中写了一种 Execution Tree（执行树）的方法， 并提到使用了 Memoization（记忆化）技术的递归方法，进行时间复杂度分析时，需要减去这部分节省的时间花销。</p>
<p>《Space Complexity - Recursion》，作者在文中介绍了递归函数的空间复杂度分析方法，其中提到空间复杂度的分析，主要分为两部分：递归相关和非递归相关的空间消耗。</p>
<p>《Tail Recursion》，这篇文章介绍一种特殊的递归方法，尾递归，并结合实例和图进行了讲解。</p>
<blockquote>
<p>Tail recursion is a recursion where the recursive call is the final instruction in the recursion function. And there should be only one recursive call in the function.<br>(尾递归是一种递归，它的递归调用是递归函数中的最后一条指令，且尾递归函数中应该只有一个递归调用。)</p>
</blockquote>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>最近有在摆弄 docker，在这里简单罗列下使用到的一些命令：</p>
<p>镜像相关的命令:</p>
<ul>
<li><p>docker search image：搜索可用的镜像</p>
</li>
<li><p>docker pull image：拉取镜像</p>
</li>
</ul>
<p>容器相关的命令：</p>
<ul>
<li>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]：创建一个新的容器并运行一个命令。</li>
<li>docker start/stop/restart CONTAINER：启动或停止或重启指定的容器。</li>
<li>docker rm [OPTIONS] CONTAINER [CONTAINER…]：删除一个或多少容器。</li>
<li>docker ps [OPTIONS]：列出容器。</li>
<li>docker logs [OPTIONS] CONTAINER：获取容器的日志。</li>
<li>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]：在运行的容器中执行命令。</li>
</ul>
<p>更多的命令可以到<a href="http://www.runoob.com/docker/docker-exec-command.html" target="_blank" rel="noopener">Docker 命令大全</a>或者到<a href="http://www.docker.com" target="_blank" rel="noopener">官网</a>上查看。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享几篇梁大的文章：<br><a href="https://mp.weixin.qq.com/s/O6UmB7YDKIYtNvqCOjNwDQ" target="_blank" rel="noopener">保持自己的技能不落伍 | 认知升级</a><br><a href="https://mp.weixin.qq.com/s/hrbC6EvWQ41rSNiPk92zWg" target="_blank" rel="noopener">构造知识反馈闭环</a><br><a href="https://mp.weixin.qq.com/s/k0HdN9ow-s9wj9s-k4Riyg" target="_blank" rel="noopener">技术探讨的正确姿势</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/author.jpg" alt="渴望飞的哺乳类">
            
              <p class="site-author-name" itemprop="name">渴望飞的哺乳类</p>
              <p class="site-description motion-element" itemprop="description">愿你仗剑走天涯，归来仍是少年</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">渴望飞的哺乳类</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
