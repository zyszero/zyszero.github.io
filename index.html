<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="愿你仗剑走天涯，归来仍是少年">
<meta property="og:type" content="website">
<meta property="og:title" content="哺乳类的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="哺乳类的博客">
<meta property="og:description" content="愿你仗剑走天涯，归来仍是少年">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="哺乳类的博客">
<meta name="twitter:description" content="愿你仗剑走天涯，归来仍是少年">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>哺乳类的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">哺乳类的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/ARTS009/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/ARTS009/" itemprop="url">ARTS打卡：第九周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T23:16:09+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第九周"><a href="#ARTS打卡：第九周" class="headerlink" title="ARTS打卡：第九周"></a>ARTS打卡：第九周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="350-Intersection-of-Two-Arrays-II-Easy"><a href="#350-Intersection-of-Two-Arrays-II-Easy" class="headerlink" title="350. Intersection of Two Arrays II(Easy)"></a>350. Intersection of Two Arrays II(Easy)</h3><blockquote><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example 1:</strong></p>
<p>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2,2]</p>
<p><strong>Example 2:</strong></p>
<p>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [4,9]</p>
<p><strong>Note:</strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
</blockquote>
<p>大致题意：</p>
<p>给两个数组，写一个方法计算它们的交集。<br><strong>注意：</strong></p>
<ol>
<li>结果中的每个元素应该出现在两个数组中显示的次数。</li>
<li>结果可以是任何顺序。</li>
</ol>
<p>解题思路1：<br>假设输入的数组为 a、b，输出的数组为 r</p>
<ol>
<li>对a、b进行排序</li>
<li>假设 i 为 a 的起始下标 0，j 为 b 的起始下标 0，k 为结果集的起始下标，从 0 开始</li>
<li>遍历数组，比较 a[i] 和 b[j]，如果 a[i] &lt; b[j]，移动下标 i，即 i++；如果 a[i] &gt; b[j]，移动下标 j，即 j++；如果 a[i] = b[j]，使得 r[k] = b[j]，且同时往前移动三个数组的下标。</li>
<li>以此类推，直至 i 等于数组a的长度且 j 等于数组b的长度，终止循环，数组 r 就是结果</li>
<li>输出数组 r 可以为 数组 a</li>
</ol>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; results = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 1. 先排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(nums1, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 1 ms, faster than 100.00% of Java online submissions for Intersection of Two Arrays II.<br>Memory Usage: 35.5 MB, less than 73.31% of Java online submissions for Intersection of Two Arrays II.</p>
<p>复杂度分析：<br>时间复杂度：O(n)。Array.sort() 时间复杂度是 O(nlogn)，遍历是 O(n)，时间复杂度主要取决于遍历。<br>空间复杂度：O(k)。</p>
<p>解题思路2：<br>因为题目对结果的顺序没有要求，所以我们可以借助 map 来实现。</p>
<ol>
<li>假设输入的数组为：数组a和数组b，i，j分别为数组a、b的下标；</li>
<li>借助一个容器 map，key 为数组的值，value 为值出现的次数和用一个 list 存储结果</li>
<li>遍历数组a，判断 map 的 key 集合中是否有 a[i]，有，则 value + 1，无，则把这个值加入到map中</li>
<li>遍历数组b，判断 map 的 key 集合中是否有 b[j]，且对应的value 是否大于 0，若是，将 b[j] 加入到结果 list 中，并将 value 减一。</li>
<li>遍历结束，将list转为数组，输出结果。</li>
</ol>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;(<span class="number">16</span>);</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">        <span class="comment">// 判断 map 的 key 集合中是否有 a[i]，有，则 value + 1，无，则把这个值加入到map中</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">            map.put(i, (<span class="keyword">int</span>) map.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以换成 java 8 的写法</span></span><br><span class="line">        <span class="comment">//map.put(nums1[i], (int) map.getOrDefault(nums1[i], 0) + 1);</span></span><br><span class="line">        <span class="comment">// 或</span></span><br><span class="line">        <span class="comment">//map.merge(nums1[i], 1, (a, b) -&gt; (int) a + (int) b);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">    <span class="comment">//判断 map 的 key 集合中是否有 b[j]，且对应的value 是否大于 0，若是，将 b[j] 加入到结果 list 中，并将 value 减一</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(i) &amp;&amp; (<span class="keyword">int</span>) map.get(i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(i);</span><br><span class="line">            map.put(i, (<span class="keyword">int</span>) map.get(i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">        r[i] = result.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 3 ms, faster than 54.64% of Java online submissions for Intersection of Two Arrays II.<br>Memory Usage: 35.7 MB, less than 66.55% of Java online submissions for Intersection of Two Arrays II.</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>这周分享：<a href="https://www.e4developer.com/2018/08/06/spring-boot-best-practices/#more-2109" target="_blank" rel="noopener">《Spring Boot – Best Practices》</a><br>作者在文中结合了自己的工作经验和其他springboot专家著作，给出了如下15条实践建议：</p>
<ol>
<li>使用自动配置</li>
<li>使用Spring Initializr来开始一个新的Spring Boot项目</li>
<li>考虑为常见的组织问题创建自己的自动配置</li>
<li>正确设计你的代码目录结构</li>
<li>保持你的 @Controller 的整洁和专一</li>
<li>围绕业务功能来构建你的 @Service</li>
<li>使数据库独立于核心业务逻辑之外</li>
<li>保持核心业务逻辑独立于 spring boot</li>
<li>推荐使用构造函数</li>
<li>熟悉并发模型</li>
<li>加强配置管理的外部化</li>
<li>提供全局异常处理</li>
<li>使用日志框架</li>
<li>测试你的代码</li>
<li>使用切片测试，让测试更容易，更专注</li>
</ol>
<p>感兴趣的小伙伴们，可以查看原文，获取更多的详情~</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>这周分享一个在工作上用到的抓包工具：Wireshark，可以直接在网上下载，是个免费软件。<br>下载地址：<a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener">https://www.wireshark.org/download.html</a><br>使用方法可以直接 google 或者度娘又或者看我在 Share 章节分享的笔记。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享：<a href="http://note.youdao.com/noteshare?id=9027a956b30d59a71eaa83a22b9f1134&amp;sub=2E3FC528AA74419F81663071028B3890" target="_blank" rel="noopener">Wireshark使用详解以及HTTP抓包</a><br>该笔记部分内容是我结合网上许多资料而来的，记录时间比较久远了，已经不清楚是从哪几篇文章上摘抄下来的了，如有侵权，联系删除。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/ARTS008/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/ARTS008/" itemprop="url">ARTS打卡：第八周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T17:02:05+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第八周"><a href="#ARTS打卡：第八周" class="headerlink" title="ARTS打卡：第八周"></a>ARTS打卡：第八周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="136-Single-Number（Easy）"><a href="#136-Single-Number（Easy）" class="headerlink" title="136. Single Number（Easy）"></a>136. Single Number（Easy）</h3><blockquote><p>Given a <strong>non-empty</strong> array of integers, every element appears twice except for one. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<p>Input: [2,2,1]<br>Output: 1</p>
<p><strong>Example 2:</strong></p>
<p>Input: [4,1,2,1,2]<br>Output: 4</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">leetcode.com/problems/single-number</a></cite></footer></blockquote>
<p><strong>题意：</strong><br>给一个不空的整型数组，除一个元素之外，其余每个元素都会出现两次，找到那个独立的元素。<br><strong>注意：</strong>你的算法应该具有线性运行时复杂度。你能不用额外的内存来实现它吗？</p>
<p><strong>解题思路1：</strong><br>根据题意，我们可以知道，输入是一个不为空的整型数组，且这个数组长度一定是奇数的，且那个不重复的元素一定是奇数位的元素，那么我们可以先对数组进行排序，然后遍历数组，假设这个数组为 nums，当 nums[i] != nums[i + 1] &amp;&amp; nums[i] != nums[i - 1] 时，nums[i] 即为那个不重复的元素，当然首尾元素要单独进行判断。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i != nums.length - <span class="number">1</span> &amp;&amp; nums[i] != nums[i + <span class="number">1</span>] &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br>Runtime: 3 ms, faster than 42.26% of Java online submissions for Single Number.<br>Memory Usage: 37.9 MB, less than 77.61% of Java online submissions for Single Number.</p>
<p><strong>解题思路2：</strong><br>还有一种解算，我在讨论区看到的，着实让我眼前一亮，从而打开了新世界的大门。<br>利用 XOR 逻辑异或去做，因为 0 ^ N = N，N ^ N = 0，所以只需以0为初始值，去遍历数组，进行异或运算，最后就能得到那个唯一的不同值。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哇，这个解法完全没想到，打开新世界的大门</span></span><br><span class="line"><span class="comment">     * 使用 XOR 逻辑异或 去做</span></span><br><span class="line"><span class="comment">     * 0 ^ N = N</span></span><br><span class="line"><span class="comment">     * N ^ N = 0</span></span><br><span class="line"><span class="comment">     * 所以只需遍历进行异或，就能得到那个唯一的不同值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            a ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Single Number.<br>Memory Usage: 38.2 MB, less than 73.27% of Java online submissions for Single Number.</p>
<p><strong>时间复杂度：</strong><code>O(n)</code><br><strong>空间复杂度：</strong><code>O(1)</code></p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周分享一篇在 Medium 上看到的文章：<a href="https://hackernoon.com/what-i-learned-from-doing-1000-code-reviews-fe28d4d11c71" target="_blank" rel="noopener">《What I learned from doing 1000 code reviews》</a>。<br>作者在这篇文章中，分享了自己在 LinkedIn 工作期间，进行大量代码审查后得出 <code>code review</code> 的四点建议：</p>
<ol>
<li><p>当出现问题时，要抛出异常。</p>
</li>
<li><p>尽可能使用最具体的类型。</p>
</li>
<li><p>使用 Optional 代替 nulls。</p>
</li>
<li><p>尽可能使用 “Unlift” 方法。</p>
</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周分享一个 IDEA 的插件：Sequence Diagram。<br>安装步骤：Setting(Ctrl + Shift + s)-&gt;Plugins-&gt;Marketplace，在插件商店直接搜索 SequenceDiagram，然后安装插件，重启 IDEA。<br>效果如下：</p>
<p>鼠标右键点击，选择 Sequence Diagram<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g35umgqp8wj309l0j5aan.jpg" alt="Sequence Diagram"></p>
<p>就可以看到自动生成的时序图了<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g35uo4flqbj30gi0mhwev.jpg" alt="时序图"></p>
<p>更多详情，可以查看 SequenceDiagram 的官网：<a href="http://vanco.github.io/SequencePlugin/" target="_blank" rel="noopener">SequencePlugin</a>。</p>
<p>如果无法通过插件商店下载，可以在这里<a href="https://plugins.jetbrains.com/plugin/8286-sequencediagram" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8286-sequencediagram</a>手动下载，然后自行安装。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>这周分享一篇梁大的文章：<a href="https://mp.weixin.qq.com/s/tP6Afu9q39RuJaAhN6_Ajw" target="_blank" rel="noopener">《人人都是 API 设计者：我对 RESTful API、GraphQL、RPC API 的思考》</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/ARTS007/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/ARTS007/" itemprop="url">ARTS打卡：第七周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T15:30:53+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第七周"><a href="#ARTS打卡：第七周" class="headerlink" title="ARTS打卡：第七周"></a>ARTS打卡：第七周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="189-Rotate-Array-Easy"><a href="#189-Rotate-Array-Easy" class="headerlink" title="189. Rotate Array(Easy)"></a>189. Rotate Array(Easy)</h3><blockquote><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p><strong>Example 1:</strong></p>
<p>Input: [1,2,3,4,5,6,7] and k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p>
<p><strong>Example 2:</strong></p>
<p>Input: [-1,-100,3,99] and k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p>
<p>Note:</p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">leetcode.com/problems/rotate-array</a></cite></footer></blockquote>
<p>题意：<br>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>需要注意是只允许使用 O(1)的额外空间，效果如 Example 所示。</p>
<p>解题思路1：使用暴力破解。<br>循环 K 次，每次遍历数组，让数组的每一位元素往前移动一位。</p>
<p>解题代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            nums[j] = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度分析：O(k * n)<br>空间复杂度分析：O(1)</p>
<p>解题思路2：<br>仔细观察 Example ，我们可以发现一个事实，旋转数组 K 次，K 个元素从数组后端挪动到前端，其余元素从前端挪到后端。<br>在这种方法中，我们首先翻转数组，然后再次翻转数组前 k 个元素，最后翻转 n - k 个元素，即其余的元素，n 为数组长度；这样就能得出答案。<br>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                           : <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">首先翻转整个数组                    : <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">其次翻转数组前 k 个元素             : <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">最后翻转数组后 n - k 个元素         :<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt; Result</span><br></pre></td></tr></table></figure>
<p>解题代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    <span class="comment">// 翻转整个数组</span></span><br><span class="line">    reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 翻转数组前 k 个元素</span></span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 翻转数组后 n - k 个元素</span></span><br><span class="line">    reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="217-Contains-Duplicate-Easy"><a href="#217-Contains-Duplicate-Easy" class="headerlink" title="217. Contains Duplicate(Easy)"></a>217. Contains Duplicate(Easy)</h3><blockquote><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<p>Input: [1,2,3,1]<br>Output: true</p>
<p><strong>Example 2:</strong></p>
<p>Input: [1,2,3,4]<br>Output: false</p>
<p><strong>Example 3:</strong></p>
<p>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">leetcode.com/problems/contains-duplicate</a></cite></footer></blockquote>
<p>题意：<br>给一个 int 类型的数组，如果数组内有重复的元素，返回 true，无则返回 false。</p>
<p>思路1：结合set集合进行判重。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：<br>时间复杂度：O(n)，set的查找和插入消耗的时间都是常量。<br>空间复杂度：O(n)，额外消耗的空间就是set的大小，取决于有多少元素加入到集合中。</p>
<p>思路2：先对数组进行排序，然后遍历进行判重。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：<br>时间复杂度：O(nlogn)。Array.sort() 时间复杂度是 O(nlogn)，遍历是 O(n)，不过遍历的次数是基于排序的情况来决定的，所以时间复杂度是 O(nlogn)。<br>空间复杂度：O(1)。空间复杂度取决于 Arrays.sort()的内部实现，如果是使用heapsort，通常会花费 O(1) 的辅助空间。</p>
<p>思路3：利用 Java 8 的 distinct() 和 count() 来做。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = Arrays.stream(nums).distinct().count();</span><br><span class="line">    <span class="keyword">return</span> nums.length == count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法从 leetcode 给出结果上来看，消耗时间最长，空间消耗也最大，时间和空间的复杂度不知如何分析<em>(:з」∠)</em>，不过代码更简洁易懂。</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html" target="_blank" rel="noopener">《UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking 》中的 6.2 I/O Models</a>。</p>
<p>作者 Stevens 在这节中详细说明了五种 IO Model 的特点和区别。</p>
<p>这五种 IO Model 分别是：BIO（blocking IO）、NIO（non-blocking IO）、 IO multiplexing、signal driven IO 和 AIO（asynchronous IO）。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>分享一篇我在学习《左耳听风》专栏做的笔记，有关于如何高效学习的：<a href="http://note.youdao.com/noteshare?id=e2c88611b709945c2c80fb23dd262b88&amp;sub=5C2758140DF44ED69E66909F9B9E1A1A" target="_blank" rel="noopener">97 - 高效学习：深度，归纳和坚持实践</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享梁大组织维护的一个知识仓库：<a href="https://www.yuque.com/server_mind/answer" target="_blank" rel="noopener">服务端思维</a>，里面有每周答疑周报、每月精读等内容，非常值得小伙伴们关注~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/ARTS006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/ARTS006/" itemprop="url">ARTS打卡：第六周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-28T21:42:20+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第六周"><a href="#ARTS打卡：第六周" class="headerlink" title="ARTS打卡：第六周"></a>ARTS打卡：第六周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>这周的 LeetCode 记录如下：</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array（Easy）"><a href="#26-Remove-Duplicates-from-Sorted-Array（Easy）" class="headerlink" title="26. Remove Duplicates from Sorted Array（Easy）"></a>26. Remove Duplicates from Sorted Array（Easy）</h3><blockquote><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<p>Given nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
<p><strong>Example 2:</strong></p>
<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<p>// nums is passed in by reference. (i.e., without making a copy)<br>int len = removeDuplicates(nums);</p>
<p>// any modification to nums in your function would be known by the caller.<br>// using the length returned by your function, it prints the first len elements.<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">leetcode.com/problems/remove-duplicates-from-sorted-array</a></cite></footer></blockquote>
<p>大致题意：<br>删除排序数组中的重复项，要求给定一个排序数组，在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>解题思路：<br>这道题，我们可以借鉴快慢指针的思想来做，不过不是用链表，是用数组进行模拟：<br>假设 slow 为慢指针，fast 为快指针，因为 nums 数组是已经排好序的升序数组，所以当 nums[slow] = nums[fast]，我们让快指针前进一步，跳过重复的数据，即 fast++；若 nums[slow] != nums[fast]时，让慢指针前进一步，即 slow++，然后交换快指针与慢指针的值，将新数据替换掉重复数据，即 nums[slow] = nums[fast]；重复步骤直至快指针走到数组尾部，即 fast == nums.length时，输出结果 slow + 1，这就是去重后的数组长度了。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当是空数组时，直接返回 0，边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow 为慢指针</span></span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fast 为 快指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">1</span>; fast &lt; nums.length; fast++</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>运行结果：<br>Runtime: 1 ms, faster than 99.98% of Java online submissions for Remove Duplicates from Sorted Array.<br>Memory Usage: 40.8 MB, less than 84.56% of Java online submissions for Remove Duplicates from Sorted Array.</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II(Easy)"></a>122. Best Time to Buy and Sell Stock II(Easy)</h3><blockquote><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<p>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<p><strong>Example 2:</strong></p>
<p>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation:<br>Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>engaging multiple transactions at the same time. You must sell before buying again.</p>
<p><strong>Example 3:</strong><br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-ii</a></cite></footer></blockquote>
<p>题意：<br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br><strong>注意：</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>解题思路：<br>这道题是看答案才明白过来的，感觉挺有趣的，虽然挺多人认为这道题就是拿来搞笑的。<br>有三种解决方法，详情请查看：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/</a><br>第三种解法，着实我眼前一亮。<br>先暂时忽略题目的限制，那么我们就可以得出这个结果：只要我们每次买进股票的价格比我们卖出的价格低的机会，就能实现利润最大化。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i - <span class="number">1</span>] &lt; prices[i]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是这篇文章：<a href="https://www.usenix.org/legacy/event/usenix04/tech/general/full_papers/elmeleegy/elmeleegy_html/html.html" target="_blank" rel="noopener">Lazy Asynchronous I/O For Event-Driven Servers</a></p>
<p>文中详细介绍了LAIO的概念，LAIO 的 API，并将其与 NIO、AIO 进行了多方面多角度的比较。</p>
<p>部分笔记如下图所示：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g2o6zi8io3j31qq1swasb.jpg" alt="LAIO"></p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>这周 VS Code 用的比较多，就分享下快捷键的使用吧。</p>
<p><code>windows</code> 版的快捷键说明文档，可以直接通过快捷键 <code>Ctrl + K，Ctrl + R</code> 获取，也可以通过这个网址获取：<a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" target="_blank" rel="noopener">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a></p>
<p>中文版的可以参看这个博客：<a href="https://blog.csdn.net/crper/article/details/54099319" target="_blank" rel="noopener">VS Code折腾记 - (2) 快捷键大全，没有更全</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享：<a href="https://mp.weixin.qq.com/s/LN8UlS5OBhl9gIIkSE2erQ" target="_blank" rel="noopener">一个NullPointerException，竟然有这么多花样！</a></p>
<p>文章来自肥朝大佬的公众号，文风一如既往的幽默风趣，知识点讲解条理清晰。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/ARTS005/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/ARTS005/" itemprop="url">ARTS打卡：第五周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-20T15:53:22+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第五周"><a href="#ARTS打卡：第五周" class="headerlink" title="ARTS打卡：第五周"></a>ARTS打卡：第五周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>这周将 Recursion I 剩余部分完成了，记录如下：</p>
<h3 id="96-Unique-Binary-Search-Trees-Medium"><a href="#96-Unique-Binary-Search-Trees-Medium" class="headerlink" title="96. Unique Binary Search Trees(Medium)"></a>96. Unique Binary Search Trees(Medium)</h3><blockquote><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p>
<p><strong>Example:</strong></p>
<p>Input: 3<br>Output: 5<br>Explanation:<br>Given n = 3, there are a total of 5 unique BST’s:</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">leetcode.com/problems/unique-binary-search-trees</a></cite></footer></blockquote>
<p>题目意思：给定n值，求出有多少结构上唯一的存储值1 … n的BST（二叉搜索树）？</p>
<p>首先我们要了解二叉搜索树（BST binary search trees）是什么?</p>
<blockquote><p>二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ol>
<footer><strong>@DevDocs</strong><cite><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9</a></cite></footer></blockquote>
<p>思路来源：<br><a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n" target="_blank" rel="noopener">DP Solution in 6 lines with explanation. F(i, n) = G(i-1) * G(n-i)</a>-G(i-1)-*-G(n-i))</p>
<p>这个帖子说的很详细，建议小伙伴们都看看。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了方便理解，申请长度为 n+1 的数组，便于最后直接返回 g[n]</span></span><br><span class="line">        <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        g[<span class="number">0</span>] = g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从g(2)出发</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// g(n) = f(1, n) + ... + f(n, n)</span></span><br><span class="line">                <span class="comment">// f(i, n) = g(i -1) * g(n - i)</span></span><br><span class="line">                <span class="comment">// g(n) = g(0) * g(n - 1) + ... + g(n - 1) * g(0)</span></span><br><span class="line">                g[i] += g[j -<span class="number">1</span>] * g[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II(Medium)"></a>95. Unique Binary Search Trees II(Medium)</h3><blockquote><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p>
<p><strong>Example:</strong></p>
<p>Input: 3<br>Output:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>Explanation:<br>The above output corresponds to the 5 unique BST’s shown below:</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">leetcode.com/problems/unique-binary-search-trees</a></cite></footer></blockquote>
<p>题目意思：给定整数n，生成存储值1 … n的所有结构上唯一的BST（二叉搜索树）。</p>
<p>思路：<br>其实跟上面那道题的思路很相像，这里大致说下：</p>
<ol>
<li>我们从 Example 可得出如果 n 是输入值的话，那么根节点可能就是 1-n 中任何一个。</li>
<li>我们可以先假设 G(n) = G(start, end) 能获取生成存储值1 … n的所有结构上唯一的BST，start是 1-n 范围内的起点，end 是终点，即 n。</li>
<li>因为是BST，所以当i为根节点时，左子树的所有结果集可以假设为 G(start, i - 1)，，右子树的所有结果集可以假设为 G(i+1, n)。</li>
<li>确认 base case，能确认最底部的根节点，然后关联有可能的左子树和右子树，最后返回一个包含了所有的情况的集合，当 start &gt; end 的时候，返回一个空集合，表示没有左/右子树。</li>
<li>确认边界条件，当 n == 0，直接返回空集合。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> genTrees(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; treeNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//  base case</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        treeNodes.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> treeNodes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; leftTreeNodes, rightTreeNodes;</span><br><span class="line">        <span class="comment">// 获取左子树的所有可能-递归公式</span></span><br><span class="line">        leftTreeNodes = genTrees(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取右子树的所有可能-递归公式</span></span><br><span class="line">        rightTreeNodes = genTrees(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode leftTreeNode :</span><br><span class="line">                leftTreeNodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode rightTreeNode :</span><br><span class="line">                    rightTreeNodes) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                root.left = leftTreeNode;</span><br><span class="line">                root.right = rightTreeNode;</span><br><span class="line">                treeNodes.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是：<a href="https://www.codechef.com/wiki/tutorial-dynamic-programming#" target="_blank" rel="noopener">Tutorial For Dynamic Programming</a></p>
<p>是一篇很好的动态规划的学习资料。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>这周分享从梁大的知识星球中学到的 tip：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g2992ekt12j30ku1gcdqj.jpg" alt="优雅退出服务小结"></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享的是小灰大大的文章：<a href="https://zhuanlan.zhihu.com/p/31628866" target="_blank" rel="noopener">漫画：什么是动态规划？</a></p>
<p>这篇文章以漫画的形式，生动形象的介绍了动态规划，让算法学起来不再那么的枯燥无味。</p>
<p>小灰的公众号还有其他以漫画形式介绍算法的文章，感兴趣的小伙伴们可以关注走一波。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/ARTS004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/ARTS004/" itemprop="url">ARTS打卡：第四周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T15:20:18+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第四周"><a href="#ARTS打卡：第四周" class="headerlink" title="ARTS打卡：第四周"></a>ARTS打卡：第四周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周记录如下：</p>
<h3 id="104-Maximum-Depth-of-Binary-Tree（Easy）"><a href="#104-Maximum-Depth-of-Binary-Tree（Easy）" class="headerlink" title="104. Maximum Depth of Binary Tree（Easy）"></a>104. Maximum Depth of Binary Tree（Easy）</h3><blockquote><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
undefined
<p>return its depth = 3.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">leetcode.com/problems/maximum-depth-of-binary-tree</a></cite></footer></blockquote>
<p>题目大致意思：<br>给一个二叉树，找到它的最大深度，最大深度是指从根节点到最远叶节点的最长路径上的节点数。</p>
<p>思路：使用DFS（深度优先遍历）</p>
<p>解法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root == null 时返回 0，是边界条件</span></span><br><span class="line">        <span class="comment">// root != null 时，必有一个节点</span></span><br><span class="line">        <span class="comment">// 假设 maxDepth(root.left) 能求出左子树的最大深度，maxDepth(root.right) 能求出右子树的最大深度，那么只需比较左右子树的最大深度，取max，再加上根节点的 1，就是二叉树的最大深度了</span></span><br><span class="line">        <span class="comment">// 其实就是利用深度优先遍历求最大深度</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录最大深度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         dsf(root, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dsf</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当前 root 为 null 时，要么根结点为 null，那么已经到达底部</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 每次达到底部时，比较当前深度和当前记录的最大深度，取两者最大值</span></span><br><span class="line">            max = Math.max(max, depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 深度 + 1</span></span><br><span class="line">        depth++;</span><br><span class="line"></span><br><span class="line">        dsf(root.left, depth);</span><br><span class="line">        dsf(root.right, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-Merge-Two-Sorted-Lists（Easy）"><a href="#21-Merge-Two-Sorted-Lists（Easy）" class="headerlink" title="21. Merge Two Sorted Lists（Easy）"></a>21. Merge Two Sorted Lists（Easy）</h3><blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">leetcode.com/problems/merge-two-sorted-lists</a></cite></footer></blockquote>
<p>题目：<br>合并两个已排序的链表，并将其作为一个新列表返回。新列表应该通过将前两个列表的节点拼接在一起来创建。</p>
<p>思路：<br>需要正确理解题意，这道题给出的例子，其实很容易误导做题者，一开始我就被误导了，直至后面才发现，这道题要的新列表是要有序。</p>
<p>我们可以用递归来解这道题，解决递归的流程一般有四步：</p>
<ol>
<li>定义一个递归方法</li>
<li>推导出递归方法和基本情况（base case）</li>
<li>如果递归方法存在重复计算的问题，使用记忆化技术进行优化</li>
<li>尽可能的使用尾递归</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1.val &gt; l2.val)&#123;</span><br><span class="line">        <span class="comment">// 当 l1 的值大于 l2 时，将 l2 当做头结点，并将头结点的下一个后继节点指向 mergeTwoLists 方法返回的节点</span></span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="comment">// 返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Two Sorted Lists.<br>Memory Usage: 37 MB, less than 97.90% of Java online submissions for Merge Two Sorted Lists.</p>
<h3 id="779-K-th-Symbol-in-Grammar（Medium）"><a href="#779-K-th-Symbol-in-Grammar（Medium）" class="headerlink" title="779. K-th Symbol in Grammar（Medium）"></a>779. K-th Symbol in Grammar（Medium）</h3><blockquote><p>On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.</p>
<p>Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).</p>
<p><strong>Examples:</strong><br>Input: N = 1, K = 1<br>Output: 0</p>
<p>Input: N = 2, K = 1<br>Output: 0</p>
<p>Input: N = 2, K = 2<br>Output: 1</p>
<p>Input: N = 4, K = 5<br>Output: 1</p>
<p>Explanation:<br>row 1: 0<br>row 2: 01<br>row 3: 0110<br>row 4: 01101001</p>
<p><strong>Note:</strong></p>
<p>N will be an integer in the range [1, 30].<br>K will be an integer in the range [1, 2^(N-1)].</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">leetcode.com/problems/k-th-symbol-in-grammar</a></cite></footer></blockquote>
<p>题目：</p>
<p>在第一行，我们写一个0。现在，在后面的每一行中，查看前面一行，并将每个出现的0替换为01，将每个出现的1替换为10。给定第N行和索引K，返回第N行中的第K个索引符号(K的值为1个索引)(1个索引)。</p>
<p>解题思路：</p>
<p>从 Example 中，我们可以得出一个规律：</p>
<p>假设 row(N) 表示第 N 行，currLen 表示当前行的长度，preLen 表示上一行的长度，row(N)[K] 表示第 N 行，下标为 k 的值。</p>
<p>当 K 值小于等于 currLen/2，即 row(N-1) 的长度时，row(N)[K] 等于 row(N-1)[k]，  当 K 值大于 currLen/2 时，row(N)[K] 等于 row(N-1)[K - preLen] 与 1 的异或值。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以已有的条件可得</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前 N 行的长度</span></span><br><span class="line">    <span class="keyword">int</span> currMaxLength = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, N-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 当前 N 行的一半长度，即上一行的长度</span></span><br><span class="line">    <span class="keyword">int</span> midLength = currMaxLength / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 当 K 值小于等于 currLen/2，即 row(N-1) 的长度时，row(N)[K] 等于 row(N-1)[k]</span></span><br><span class="line">    <span class="keyword">if</span> (K &lt;= midLength)&#123;</span><br><span class="line">        <span class="keyword">return</span> kthGrammar(N - <span class="number">1</span>, K);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//  当 K 值大于 currLen/2 时，row(N)[K] 等于 row(N-1)[K - preLen] 与 1 的异或值</span></span><br><span class="line">        <span class="keyword">return</span> kthGrammar(N-<span class="number">1</span>, K- midLength) ^ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是以下三篇文章，都是与异步 I/O 模型有关的：</p>
<ol>
<li><a href="https://www.slideshare.net/e456/tyma-paulmultithreaded1" target="_blank" rel="noopener">Thousands of Threads and Blocking l/O:The Old Way to Write Java Servers Is New Again（and Way Better）</a></li>
<li><a href="http://116.199.9.132:83/2Q2WEFD048125304E64CA8C982B0A997B2574B94E071_unknown_A75C52C9971B3CB616973B1E53478BF698F0BE07_6/gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Scalable IO in Java</a></li>
<li><a href="https://developer.ibm.com/articles/l-async/" target="_blank" rel="noopener">Boost application performance using asynchronous I/O</a></li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>感觉这周没学到什么小技巧Orz，就分享一个小发现吧，IDEA 自带的一个功能， View -&gt; Show ByteCode，效果如下：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g226mh3ynkj313t0m076j.jpg" alt="View -&gt; Show ByteCode"></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享知秋大佬的有关 NIO 的系列文章：</p>
<ul>
<li><a href="https://juejin.im/post/5c2cc075f265da611037298e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之BIO</a></li>
<li><a href="https://juejin.im/post/5c2e23156fb9a049ff4e4009" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 上</a></li>
<li><a href="https://juejin.im/post/5c34d1dd6fb9a049c84fa2ce" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 中</a></li>
<li><a href="https://juejin.im/post/5c3a01d851882525c55fad36" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 之 Selector</a></li>
<li><a href="https://juejin.im/post/5c4738c151882525c638144e" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 Buffer解读 上</a></li>
<li><a href="https://juejin.im/post/5c653140518825625e4abfc6" target="_blank" rel="noopener">BIO到NIO源码的一些事儿之NIO 下 Buffer解读 下</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/06/ARTS003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/06/ARTS003/" itemprop="url">ARTS打卡：第三周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T15:53:32+08:00">
                2019-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS打卡：第三周"><a href="#ARTS打卡：第三周" class="headerlink" title="ARTS打卡：第三周"></a>ARTS打卡：第三周</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周记录如下：</p>
<h3 id="206-Reverse-Linked-List（Easy）"><a href="#206-Reverse-Linked-List（Easy）" class="headerlink" title="206. Reverse Linked List（Easy）"></a>206. Reverse Linked List（Easy）</h3><blockquote><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong><br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode.com/problems/reverse-linked-list</a></cite></footer></blockquote>
<p>题目：反转单链表，示例如上所示。</p>
<p>思路1： 首先让单链表的头结点的前驱节点指向NULL，然后遍历链表节点，改变当前节点的后继节点为前驱节点，直至循环结束，返回尾结点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录上一个节点（一开始为null，是为了让单链表的头结点的前驱节点指向NULL）</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// 循环遍历至尾结点</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 临时节点，保存当前节点的后继节点</span></span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        <span class="comment">// 改变当前节点的后继节点为前驱节点</span></span><br><span class="line">        curr.next = prev;</span><br><span class="line">        <span class="comment">// 移动节点</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回旧单链表的尾结点（即反转后的新单链表的头结点）</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.<br>Memory Usage: 37.7 MB, less than 29.48% of Java online submissions for Reverse Linked List.</p>
<p>思路2：<br>使用递归，来自官方的解法：</p>
<blockquote><p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let’s assume the list is: n1 → … → nk-1 → nk → nk+1 → … → nm → Ø</p>
<p>Assume from node nk+1 to nm had been reversed and you are at node nk.</p>
<p>n1 → … → nk-1 → nk → nk+1 ← … ← nm</p>
<p>We want nk+1’s next node to point to nk.</p>
<p>So,</p>
<p>nk.next.next = nk;</p>
<p>Be very careful that n1’s next must point to Ø. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p>
</blockquote>
<p>大致意思：</p>
<p>我们可以假设单链表是这样的：n1 → … → nk-1 → nk → nk+1 ← … ← nm，现在想要 nk+1 的后继节点指向nk，即 （nk+1.next = nk）。</p>
<p>所以我们的 Base Case 是： nk.next.next = nk。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当头结点为 null，直接返回 null（边界条件）</span></span><br><span class="line">    <span class="comment">// head.next == null，递归终止的条件 </span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前节点的后继节点，即 nk+1</span></span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">// 因为 n1 的前驱节点要指向 null</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.<br>Memory Usage: 37.7 MB, less than 41.78% of Java online submissions for Reverse Linked List.</p>
<h3 id="509-Fibonacci-Number（Easy）"><a href="#509-Fibonacci-Number（Easy）" class="headerlink" title="509. Fibonacci Number（Easy）"></a>509. Fibonacci Number（Easy）</h3><blockquote><p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</p>
<p>Given N, calculate F(N).</p>
<p><strong>Example 1:</strong></p>
<p>Input: 2<br>Output: 1<br>Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</p>
<p><strong>Example 2:</strong></p>
<p>Input: 3<br>Output: 2<br>Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</p>
<p><strong>Example 3:</strong></p>
<p>Input: 4<br>Output: 3<br>Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</p>
<p><strong>Note:</strong></p>
<p>0 ≤ N ≤ 30.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">leetcode.com/problems/fibonacci-number</a></cite></footer></blockquote>
<p>题目：<br>斐波纳契数，哈哈哈，大家是不是很眼熟呐，一道很经典的题目，这里不解释题目意思了。</p>
<p>解题思路：<br>这里先要引入一个概念，Memoization（记忆化）。</p>
<blockquote>
<p>Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. (Source: wikipedia)</p>
</blockquote>
<p>简单来说，记忆化技术是用来解决递归方法中出现重复计算的问题，使用缓存保存之前计算过的结果，使得相同输入，无需重复计算，直接从缓存中获取值。</p>
<p>在这道题中，我们可以看出，有很多次的重复计算，比如：F(4) = F(3) + F(2) = F(2) + F(2) + F(1) = F(1) + F(0) + F(1) + F(0) + F(1)。</p>
<p>所以我们可以引入记忆化技术。从上述的例子中，可以推导出递归公式为：F(n) = F(n-1) + F(n-2)。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个map集合，作为缓存</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断输入的值 N ，在缓存中是否存在计算结果，有的话直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cacheMap.containsKey(N))&#123;</span><br><span class="line">            <span class="keyword">return</span> cacheMap.get(N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="comment">// F(1) = 1, F(0) = 0，所以当 N &lt; 2 时，可以直接返回 N 。</span></span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            result =  N;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把计算结果放到缓存中</span></span><br><span class="line">        cacheMap.put(N, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>运行结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Fibonacci Number.<br>Memory Usage: 31.7 MB, less than 100.00% of Java online submissions for Fibonacci Number.</p>
<p>我在 submissions 中发现一个有趣的答案，使用 Java 8 特性解题的，分享给大家：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// F(1) = 1, F(0) = 0，所以当 N &lt; 2 时，可以直接返回 N 。</span></span><br><span class="line">        <span class="keyword">if</span> ( N == <span class="number">0</span> || N == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// .limit(N + 1)： 循环 N + 1 次，每次生成一个数组为[f[1], f[0]+f[1]]，f 为上一个数组，new int[]&#123;0, 1&#125;为初始值，.mapToInt(f -&gt; f[0])：获取每个数组的f[0]，形成IntStream；.max()：获取流中数值最大的元素，.getAsInt()： 转成 int 数值。</span></span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, f -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;f[<span class="number">1</span>], f[<span class="number">0</span>] + f[<span class="number">1</span>]&#125;)</span><br><span class="line">                .limit(N + <span class="number">1</span>)</span><br><span class="line">                .mapToInt(f -&gt; f[<span class="number">0</span>])</span><br><span class="line">                .max()</span><br><span class="line">                .getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算结果：<br>Runtime: 38 ms, faster than 5.57% of Java online submissions for Fibonacci Number.<br>Memory Usage: 32.3 MB, less than 100.00% of Java online submissions for Fibonacci </p>
<h3 id="70-Climbing-Stairs-Easy"><a href="#70-Climbing-Stairs-Easy" class="headerlink" title="70. Climbing Stairs(Easy)"></a>70. Climbing Stairs(Easy)</h3><blockquote><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
undefined
<p><strong>Example 2:</strong></p>
undefined
</blockquote>
<p>题目大致意思：<br>你正在爬楼梯，需要n步才能达到楼顶。 每次你可以爬1或2步。那可以通过多少不同的方式登顶？ 注意：给定n将是一个正整数。</p>
<p>核心思路：<br>把握一个核心思想，就是达到楼顶的最后步数，要么是1，要么是2。<br>我们假设当 n = 4 时， 可能的方式为 F(3) + 1 或者 F(2) + 2，即 F(4) = F(3) + F(2)，所以我们可以推导出公式为：F(n) = F(n-1) + F(n -2)。</p>
<p>解法一：递归 + 记忆化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缓存数组，用于存储F(n)的值，下标对应 n 值。</span></span><br><span class="line">        <span class="keyword">int</span> memo[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> climb_Stairs(<span class="number">0</span>, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climb_Stairs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> memo[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = climb_Stairs(i + <span class="number">1</span>, n, memo) + climb_Stairs(i + <span class="number">2</span>, n, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>解法二：动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 n+1 的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 有0下标的值，是为方便F(2)的计算</span></span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    result[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环 n 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 根据 f(i -1) 和 f(i -2) 的值动态计算 f(i)的值</span></span><br><span class="line">        result[i] = result[i -<span class="number">1</span>] + result[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>解法三：Fibonacci Number<br>不知你们发现没，这题跟我们上一题斐波纳契数是一样，都是F(n) = F(n-1) + F(n-2)，代码跟解法二基本一样，只是数组换成了整形，在空间消耗上进行了优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>LeetCode上还有几种解法，在时间复杂度上有了进一步的优化，感兴趣的小伙伴们，可以自行查看：<a href="https://leetcode.com/problems/climbing-stairs/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/solution/</a></p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是 LeetCode Recursion I 上的三篇文章：<a href="https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/1669/" target="_blank" rel="noopener">Time Complexity - Recursion</a> 、 <a href="https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/1671/" target="_blank" rel="noopener">Space Complexity - Recursion</a> 和 <a href="https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/2374/" target="_blank" rel="noopener">Tail Recursion</a>。</p>
<p>《Time Complexity - Recursion》，作者在这篇文章中介绍了如何对递归方法的时间复杂度进行分析。文中写了一种 Execution Tree（执行树）的方法， 并提到使用了 Memoization（记忆化）技术的递归方法，进行时间复杂度分析时，需要减去这部分节省的时间花销。</p>
<p>《Space Complexity - Recursion》，作者在文中介绍了递归函数的空间复杂度分析方法，其中提到空间复杂度的分析，主要分为两部分：递归相关和非递归相关的空间消耗。</p>
<p>《Tail Recursion》，这篇文章介绍一种特殊的递归方法，尾递归，并结合实例和图进行了讲解。</p>
<blockquote>
<p>Tail recursion is a recursion where the recursive call is the final instruction in the recursion function. And there should be only one recursive call in the function.<br>(尾递归是一种递归，它的递归调用是递归函数中的最后一条指令，且尾递归函数中应该只有一个递归调用。)</p>
</blockquote>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>最近有在摆弄 docker，在这里简单罗列下使用到的一些命令：</p>
<p>镜像相关的命令:</p>
<ul>
<li><p>docker search image：搜索可用的镜像</p>
</li>
<li><p>docker pull image：拉取镜像</p>
</li>
</ul>
<p>容器相关的命令：</p>
<ul>
<li>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]：创建一个新的容器并运行一个命令。</li>
<li>docker start/stop/restart CONTAINER：启动或停止或重启指定的容器。</li>
<li>docker rm [OPTIONS] CONTAINER [CONTAINER…]：删除一个或多少容器。</li>
<li>docker ps [OPTIONS]：列出容器。</li>
<li>docker logs [OPTIONS] CONTAINER：获取容器的日志。</li>
<li>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]：在运行的容器中执行命令。</li>
</ul>
<p>更多的命令可以到<a href="http://www.runoob.com/docker/docker-exec-command.html" target="_blank" rel="noopener">Docker 命令大全</a>或者到<a href="http://www.docker.com" target="_blank" rel="noopener">官网</a>上查看。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享几篇梁大的文章：<br><a href="https://mp.weixin.qq.com/s/O6UmB7YDKIYtNvqCOjNwDQ" target="_blank" rel="noopener">保持自己的技能不落伍 | 认知升级</a><br><a href="https://mp.weixin.qq.com/s/hrbC6EvWQ41rSNiPk92zWg" target="_blank" rel="noopener">构造知识反馈闭环</a><br><a href="https://mp.weixin.qq.com/s/k0HdN9ow-s9wj9s-k4Riyg" target="_blank" rel="noopener">技术探讨的正确姿势</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/31/java 8-optional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/31/java 8-optional/" itemprop="url">使用Java 8 的 Optional 类进行优雅的判空</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-31T15:30:13+08:00">
                2019-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-8/" itemprop="url" rel="index">
                    <span itemprop="name">Java 8</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用Java-8-的-Optional-类进行优雅的判空"><a href="#使用Java-8-的-Optional-类进行优雅的判空" class="headerlink" title="使用Java 8 的 Optional 类进行优雅的判空"></a>使用Java 8 的 Optional 类进行优雅的判空</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇是身为技术菜鸟的博主写的第一篇技术文章，新手上路，文笔粗糙，还请大家多多担待。</p>
<p>之所以写这篇文章，起因是我看完《Java 8 in Action》 也有一段时间了，在日常工作中，也经常使用 Java 8 的语法，就打算写下有关 Java 8 的一系列文章，用于自我复习和总结，加深自己对 Java 8的理解和使用，好了，言归正传，下面就让我们进入主题吧。</p>
<p>你是否曾经被 NullPointerException 异常折磨的苦不堪言？你是否曾为复杂的POJO 类写非空判断，为那多个 if xxx != null 或多层嵌套 if xxx != null 的代码感到烦恼心累？</p>
<p>呐，程序猿们，我们是时候用Java 8 的 Optional 类进行优雅的判空啦，当然，如果你用的是 Java 8 的话<em>(:з」∠)</em>。</p>
<h2 id="Optional-是什么？"><a href="#Optional-是什么？" class="headerlink" title="Optional 是什么？"></a>Optional 是什么？</h2><p>java.util.Optional<t> 类是 Java 8 引入的一个新的类，是一个容器，可以保存类型为T的值，也可以保存null值，它提供了许多有用的方法，使得我们可以不用显示进行空值检查。</t></p>
<h2 id="Optional-的类方法"><a href="#Optional-的类方法" class="headerlink" title="Optional 的类方法"></a>Optional 的类方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>static<t> Optional<t> empty()</t></t></td>
<td>返回一个空的 Optional 实例</td>
</tr>
<tr>
<td>static <t> Optional<t> of(T value)</t></t></td>
<td>返回一个包含指定 value 的 Optional，如果 value 为空，则抛出 NullPointerException</td>
</tr>
<tr>
<td>static <t> Optional<t> ofNullable(T value)</t></t></td>
<td>将指定的值用 Optional 封装之后返回，如果 value 为null，则返回一个空的 Optional 对象</td>
</tr>
<tr>
<td>T get()</td>
<td>如果 Optional 包含有值，则返回该值，否则抛出 NoSuchElementException 异常</td>
</tr>
<tr>
<td>boolean isPresent()</td>
<td>如果 Optional 有值，则返回 true，否则返回 false</td>
</tr>
<tr>
<td>void ifPresent(Consumer&lt;? super T&gt; action)</td>
<td>如果 Optional 有值，则使用该值调用 consumer，否则不做任何事情</td>
</tr>
<tr>
<td>Optional<t> filter(Predicate&lt;? super T&gt; predicate)</t></td>
<td>如果 Optional 有值，且该值与给定的 predicate 匹配，则返回 该 Optional，否则返回一个空的 Optional</td>
</tr>
<tr>
<td><u> Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></u></td>
<td>如果 Optional 有值存在，就对该值执行提供的mapping 函数调用</td>
</tr>
<tr>
<td><u> Optional<u> flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U&gt;&gt; mapper)</u></u></td>
<td>如果 Optional 有值存在，就对该值执行提供的mapping 函数调用，返回一个Optional 类型的值，否则就返回一个空的Optional 对象</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>如果 Optional 有值，则将其返回，否则返回指定 other 值</td>
</tr>
<tr>
<td>T orElseGet(Supplier&lt;? extends T&gt; supplier)</td>
<td>如果 Optional 有值则将其返回，否则返回一个由指定的Supplier 接口生成的值</td>
</tr>
<tr>
<td>T orElseThrow()</td>
<td>如果 Optional 有值，则将其返回，否则抛出 NoSuchElementException 异常</td>
</tr>
<tr>
<td><x extends throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</x></td>
<td>如果 Optional 有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常</td>
</tr>
<tr>
<td>Stream<t> stream()</t></td>
<td>如果 Optional 有值，则返回一个包含 Optional 的 Stream，否则返回一个空的 Stream</td>
</tr>
</tbody>
</table>
<h2 id="Optional-的应用实例"><a href="#Optional-的应用实例" class="headerlink" title="Optional 的应用实例"></a>Optional 的应用实例</h2><p>上面基本上列出了 Optional 类的所有方法，下面挑几个常用的方法进行介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Basket</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Apple apple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Double weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">20.00</span>);</span><br><span class="line">        Basket basket = <span class="keyword">new</span> Basket(apple);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 返回一个包含指定 apple 的 Optional，如果 apple 为空，则抛出 NullPointerException</span></span><br><span class="line">            Optional&lt;Apple&gt; optionalApple1 = Optional.of(apple);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 apple 用 Optional 封装之后返回，如果 apple 为null，则返回一个空的 Optional 对象</span></span><br><span class="line">        <span class="comment">// 推荐采用这种方式</span></span><br><span class="line">        Optional&lt;Apple&gt; optionalApple2 = Optional.ofNullable(apple);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 optionalApple 包含有值，则返回该值，否则抛出 NoSuchElementException 异常</span></span><br><span class="line">            Apple apple1 = optionalApple2.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不想get()抛出异常，可以使用 orElse() 方法</span></span><br><span class="line">        <span class="comment">// 如果 optionalApple2 有值，则将其返回，否则返回指定 null 值</span></span><br><span class="line">        Apple apple1 = optionalApple2.orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 optionalApple2 有值存在，就对该值执行提供的mapping 函数调用</span></span><br><span class="line">        Optional&lt;Double&gt; weightOptional = optionalApple2.map(Apple::getWeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以与 get() 一起使用，或者与 orElse() 一起使用</span></span><br><span class="line">        Double weight1 = optionalApple2.map(Apple::getWeight).get();</span><br><span class="line">        Double weight2 = optionalApple2.map(Apple::getWeight).orElse(<span class="number">00.00</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 Basket 中 获取 Apple 的 weight</span></span><br><span class="line">        Double appleWeight1 = Optional.ofNullable(basket)</span><br><span class="line">                .map(Basket::getApple)</span><br><span class="line">                .map(Apple::getWeight)</span><br><span class="line">                .orElse(<span class="number">00.00</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 orElseThrow</span></span><br><span class="line">        Double appleWeight2 = Optional.ofNullable(basket)</span><br><span class="line">                .map(Basket::getApple)</span><br><span class="line">                .map(Apple::getWeight)</span><br><span class="line">                .orElseThrow(NullPointerException::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Optional-进行优雅判空"><a href="#使用-Optional-进行优雅判空" class="headerlink" title="使用 Optional 进行优雅判空"></a>使用 Optional 进行优雅判空</h2><p>还是用上面列举的类，如果不用使用 Optional，想要获取 Basket 类内的 Apple 类的 weight 值，得这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAppleWeight</span><span class="params">(Basket basket)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (basket != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Apple apple = basket.getApple();</span><br><span class="line">        <span class="keyword">if</span> (apple != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Double weight = apple.getWeight();</span><br><span class="line">            <span class="keyword">if</span> (weight != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看这个 if 嵌套，emm…，这还是较为简单的 pojo 类，如果是复杂的，简直不堪入目啊。<br>而在 Optional 的加持下，只需这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAppleWeight</span><span class="params">(Basket basket)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(basket)</span><br><span class="line">            .map(Basket::getApple)</span><br><span class="line">            .map(Apple::getWeight)</span><br><span class="line">            .orElse(<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间代码就清爽了，嘻嘻，人也跟着欢快起来了。</p>
<p>当然 Optional 不止能进行优雅的判空，还可以利用 Optional 的其它的API，进行一些神奇的操作，比如使用 filter 进行参数校验之类的。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li>《Java 8 in Action》</li>
<li><a href="http://www.importnew.com/26066.html" target="_blank" rel="noopener">Java8 如何正确使用 Optional</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/ARTS002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/ARTS002/" itemprop="url">ARTS打卡：第二周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T23:21:10+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS-第二周分享"><a href="#ARTS-第二周分享" class="headerlink" title="ARTS 第二周分享"></a>ARTS 第二周分享</h1><blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周记录如下：</p>
<h3 id="118-Pascal’s-Triangle（Easy）"><a href="#118-Pascal’s-Triangle（Easy）" class="headerlink" title="118. Pascal’s Triangle（Easy）"></a><strong>118. Pascal’s Triangle（Easy）</strong></h3><blockquote>
<p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.<br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="Pascal&#39;s Triangle"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.<br>Example:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">5</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>题目大致意思：给定一个负整数，生成一个帕斯卡三角形，如Example所示。</p>
<p>思路：这里的动图非常形象，我们可以从动图中看出，每个数组的首尾元素是 1，且数组长度与深度一致，紧接着我们将动图转换成阶梯型，代入二维数组的概念来看，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>就可以很容易看出 除首尾元素为 1 外，其余元素等于上一个数组对应下标的值加上上一个数组对应下标-1的值，即curr[n] = prev[n] + prev[n-1]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getPascalsTriangle(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; pascalsTriangle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pascalsTriangle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首个数组一定是 1</span></span><br><span class="line">        ArrayList&lt;Integer&gt; firstArray = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        firstArray.add(<span class="number">1</span>);</span><br><span class="line">        pascalsTriangle.add(firstArray);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 上一个数组</span></span><br><span class="line">            List&lt;Integer&gt; preList = pascalsTriangle.get(i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 每个数组头部元素总是 1</span></span><br><span class="line">            temp.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                temp.add(preList.get(j) + preList.get(j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个数组尾部元素总是 1</span></span><br><span class="line">            temp.add(<span class="number">1</span>);</span><br><span class="line">            pascalsTriangle.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pascalsTriangle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 0 ms, faster than 100.00% of Java online submissions for Pascal’s Triangle.<br>Memory Usage: 32.7 MB, less than 100.00% of Java online submissions for Pascal’s Triangle.</p>
<h3 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a>119. Pascal’s Triangle II</h3><blockquote><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><strong>Example:</strong><br>Input: 3<br>Output: [1,3,3,1]<br>Follow up:</p>
<p>Could you optimize your algorithm to use only O(k) extra space?</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">leetcode.com/problems/pascals-triangle-ii</a></cite></footer></blockquote>
<p>题目大致意思：跟题118差不多，要求只使用O（k）额外空间，如Example所示。</p>
<p>思路：跟题118差不多一致，可以用递归实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 终止条件</span></span><br><span class="line">            <span class="keyword">if</span> (rowIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(rowIndex + <span class="number">1</span>);</span><br><span class="line">                result.add(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取上一个数组，利用递归获取</span></span><br><span class="line">            List&lt;Integer&gt; prevList = getRow(rowIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 从后往前遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowIndex - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 即 curr[i] = prev[i] + prev[i - 1]</span></span><br><span class="line">                prevList.set(i, prevList.get(i) + prevList.get(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入尾部元素 1</span></span><br><span class="line">            prevList.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> prevList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>Runtime: 1 ms, faster than 84.50% of Java online submissions for Pascal’s Triangle II.<br>Memory Usage: 32.3 MB, less than 100.00% of Java online submissions for Pascal’s Triangle II.</p>
<p>从结果上来看，运行时间上，还可以进行优化，最后脑细胞不够，想不出如何优化，查看了下Runtime：0ms答案，答案如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">long</span> nk = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">            res.add((<span class="keyword">int</span>)nk);</span><br><span class="line">            nk = nk * (rowIndex - i) / (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的是专栏里推荐的两篇文章：<a href="http://norvig.com/21-days.html" target="_blank" rel="noopener">《Teach Yourself Programming in Ten Years》</a>（<a href="https://liuyandong.com/2017/10/25/122/" target="_blank" rel="noopener">中英对照</a>） 和 <a href="http://brianknapp.me/most-basic-things-every-programmer-should-know/" target="_blank" rel="noopener">《What are some of the most basic things every programmer should know?》</a></p>
<p>作者在这篇 《Teach Yourself Programming in Ten Years》（十年学会编程）文章中提出了当前人们急于求成这种不好的风气，批判了诸如24小时或天学会XXX的书籍的无用，并举了诸多著名的例子来证明“十年”学会编程的观点，比如“10000小时理论”等。</p>
<p>作者还列出自己编程成功的秘笈，以下列出我印象比较深的几点：</p>
<ol>
<li>对编程感兴趣，从编程中获取乐趣，这样才能坚持10000小时或10年。</li>
<li>动手编程，边学边做，实践出真知。</li>
<li>和其他的程序猿交流，能比培训或看书收获更多。</li>
<li>在大学期间或加上研究生期间，深入计算机领域学习；如果不喜欢读书，那直接通过工作获取经验也可以，但不能死读书，计算机科学并不能让你成为编程专家，正如学习颜料和画笔不能让你成为一个画家一样。</li>
<li>与其他程序猿一起参与一些项目，在一些项目中成为最好的程序猿，尽自己最大的能力去带领团队，用自己的视野去启发别人；在一些项目中当最差的程序猿，当你是最差的时候，学习其他大牛。</li>
<li>接收他人项目时，理解他人写的代码，修复他人的BUG；思考设计自己的软件，让其容易被他人维护。</li>
<li>至少学会6种编程语言，一种支持抽象类的语言（例如 C++ 或 Java ）,一种支持函数的语言（例如 Lisp，ML 或 Haskell），一种支持语义抽象的语言（例如 Lisp ）,一种支持声明性规范的语言（例如 Prolog 或 C++ templates ），一种强调并行性的语言（例如 Go 或 Clojure ）。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>学习编程是一件漫长且要持续投入的事情，不存在任何的捷径，想要一蹴而就无疑是痴人说梦，是需要一步一个脚印，脚踏实地的努力才行，就如上一周分享的文章所说，跨越编程拐点之前，将可能是一段令人沮丧的经历，所以我们要进行有针对性的日复一日年复一年的训练，并且要有合理的反馈渠道，根据反馈做出相对的改进，需要多一点正向反馈，这样才能坚持下去，跨越一个接一个的拐点，最后达成“十年学习编程”的成就。</p>
<p>《What are some of the most basic things every programmer should know?》，这篇文章不长，感兴趣的小伙伴们可以自行查看。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>介绍一个开发利器 Lombok，以注解的形式，简化消除getter、setter、equals、hashcode、toString等代码。</p>
<p>官方地址：<a href="https://projectlombok.org/" target="_blank" rel="noopener">https://projectlombok.org/</a><br>github地址：<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="noopener">https://github.com/rzwitserloot/lombok</a></p>
<p>具体使用方法，可以参看<a href="https://blog.52itstyle.vip/archives/1418/" target="_blank" rel="noopener">JAVA奇技淫巧简化代码之lombok</a>这篇博客。</p>
<p>上面那篇博客只介绍了 Eclipse，如果是InteliJ IDEA 的用户，需在安装一个Lombok插件，如下图所示：<br><img src="http://ww1.sinaimg.cn/large/007hWkdxgy1g1lacdoy4aj30z80mlq3v.jpg" alt="lombok"></p>
<p>这里介绍一下 @Builder 这个注解，可以很容易生成建造者模式的代码，效果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double wight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = Apple.builder().color(<span class="string">"Red"</span>).wight(<span class="number">100.0</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过链式设置类的属性值，尤其是当类属性很多时，这样非常方便，且代码看起来很优雅。通过注解生成代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> Double wight;</span><br><span class="line"></span><br><span class="line">    Apple(String color, Double wight) &#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.wight = wight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Apple.<span class="function">AppleBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple.AppleBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String color;</span><br><span class="line">        <span class="keyword">private</span> Double wight;</span><br><span class="line"></span><br><span class="line">        AppleBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Apple.<span class="function">AppleBuilder <span class="title">color</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Apple.<span class="function">AppleBuilder <span class="title">wight</span><span class="params">(Double wight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.wight = wight;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Apple <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple(<span class="keyword">this</span>.color, <span class="keyword">this</span>.wight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String var10000 = <span class="keyword">this</span>.color;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.wight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多详情请查看<a href="https://projectlombok.org/features/Builder" target="_blank" rel="noopener">https://projectlombok.org/features/Builder</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://zyszero.github.io/2019/03/31/java%208-optional/" target="_blank" rel="noopener">使用 Java 8 的 Optional 类进行优雅的判空</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/24/ARTS001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="渴望飞的哺乳类">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哺乳类的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/ARTS001/" itemprop="url">ARTS打卡：第一周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T16:07:44+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ARTS/" itemprop="url" rel="index">
                    <span itemprop="name">ARTS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARTS-第一周分享"><a href="#ARTS-第一周分享" class="headerlink" title="ARTS 第一周分享"></a>ARTS 第一周分享</h1><p>ARTS 是耗子叔发起的一次活动，感兴趣的小伙伴们可以到知乎上查看<a href="https://www.zhihu.com/question/301150832/answer/529809529" target="_blank" rel="noopener">极客时间《左耳听风》发起的ARTS挑战怎么参加？</a></p>
<blockquote><p>每周完成一个ARTS：</p>
<ol>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>LeetCode 的萌新用户，这周做的几道题是 Recursion 1 里面的题目，记录如下：</p>
<h3 id="344-Reverse-String（Easy）"><a href="#344-Reverse-String（Easy）" class="headerlink" title="#344. Reverse String（Easy）"></a><strong>#344. Reverse String（Easy）</strong></h3><blockquote><p>Write a function that reverses a string. The input string is given as an array of characters char[].<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>You may assume all the characters consist of printable ascii characters.<br>Example 1 ：<br>Input: [“h”,”e”,”l”,”l”,”o”]<br>Output: [“o”,”l”,”l”,”e”,”h”]<br>Example 2 ：<br>Input: [“H”,”a”,”n”,”n”,”a”,”h”]<br>Output: [“h”,”a”,”n”,”n”,”a”,”H”]</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/reverse-string" target="_blank" rel="noopener">leetcode.com/problems/reverse-string</a></cite></footer></blockquote>
<p>这道题的大致意思是写一个方法，用于反转输入的字符数组，不允许额外分配多一个数组，要求只能使用O(1)的额外内存来实现。<br>解法简单，就直接上代码了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">int</span> midIndex = s.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; midIndex; i++) &#123;</span><br><span class="line">            temp = s[i];</span><br><span class="line">            s[i] = s[s.length - <span class="number">1</span> -i];</span><br><span class="line">            s[s.length - <span class="number">1</span> - i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴一个在 Discuss 里看到的答案，利用 ascii 来实现的，是我想不到的思路<em>(:з」∠)</em>：<a href="https://leetcode.com/problems/reverse-string/discuss/257311/Java-two-pointer-solution-without-temp-var" target="_blank" rel="noopener">[Java] two pointer solution without temp var
</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=s.length-<span class="number">1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">            s[i]=(<span class="keyword">char</span>)(s[j]-s[i]);</span><br><span class="line">            s[j]=(<span class="keyword">char</span>)(s[j]-s[i]);</span><br><span class="line">            s[i]=(<span class="keyword">char</span>)(s[j]+s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-Swap-Nodes-in-Pairs（Medium）"><a href="#24-Swap-Nodes-in-Pairs（Medium）" class="headerlink" title="#24. Swap Nodes in Pairs（Medium）"></a><strong>#24. Swap Nodes in Pairs（Medium）</strong></h3><blockquote><p>Given a linked list, swap every two adjacent nodes and return its head.<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.<br>Example:<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<footer><strong>@DevDocs</strong><cite><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">leetcode.com/problems/swap-nodes-in-pairs</a></cite></footer></blockquote>
<p>题目的大致意思：给定一个链表，交换每两个相邻节点并返回其头部。 只能更改节点本身。</p>
<p>解题思路：这道题可以当做是递归问题，解决递归问题两大关键点：</p>
<ul>
<li>recurrence relation：the relationship between the result of a problem and the result of its subproblems.（即大问题分解为小问题的规律，基于这个规律写出递推公式）</li>
<li>base case：the case where one can compute the answer directly without any further recursion calls. （即递归的终止条件）</li>
</ul>
<p>所以我们第一步，就是先找出递归关系，将大问题分解为小问题。</p>
<p>以 Example 提供的数据为例，将两个节点划分为一组来看，会发现（1-&gt;2），交换位置后为（2-&gt;1），即将 2 作为头部节点，并指向 1，且 1 节点要指向下一组的头部节点，然后返回头部2；下一组（3-&gt;4），通过同样的操作，变为（4-&gt;3），3 指向了下一组的头部节点，然后返回头部节点 4。</p>
<p>你看，递归关系就出来了，都是把原头结点的下一个节点当做当前头结点，把原头结点指向下一组的头结点，然后把当前头节点的下一个节点指向原头结点，最后返回当前头结点。（表述能力有点渣，请见谅<em>(:з」∠)</em> ）。</p>
<p>把递归关系写成方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临时变量保存原先的头结点</span></span><br><span class="line">    ListNode tmp = head;</span><br><span class="line">    <span class="comment">// 把原先头结点的下一个节点当做当前头结点</span></span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="comment">// 把原头结点指向下一组的头结点</span></span><br><span class="line">    tmp.next = swapPairs(head.next);</span><br><span class="line">    <span class="comment">// 把当前节点的下一个节点指向原先头结点</span></span><br><span class="line">    head.next = tmp;</span><br><span class="line">    <span class="comment">// 返回当前头结点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还没完，我们还需要找到递归的终止条件，即当：</p>
<ul>
<li>假设传入的是一个空节点时，直接返回空节点。</li>
<li>假设传入的节点没有下一个节点时，直接返回当前节点。</li>
</ul>
<p>这时答案就出来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode tmp = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            tmp.next = swapPairs(head.next);</span><br><span class="line">            head.next = tmp;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读了一篇在《左耳听风》第71讲中推荐阅读的文章：<a href="http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/" target="_blank" rel="noopener">《The Key To Accelerating Your Coding Skills》</a>。</p>
<p>作者在这篇文章中讲述了如何有效地快速提高自己的编程能力，认为在学习编程的过程中，存在着编码拐点，一旦通过这个拐点，作为一个开发人员的操作方式，将会有很大的不同。通过拐点之前，将可能是一段令人沮丧的经历，但一旦它过去了，它就会让你变得无比强大。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>分享一个关于 Intellij IDEA Debug的小技巧：<br>有时候我们进入方法体之后，还想退回到方法体外时，比如果手速过快，点多了几下F8/F9，这时，只需点击 <strong>Drop Frame</strong>，即可退回方法体外，如下图所示：<br><img src="https://user-images.githubusercontent.com/22961204/54867798-865f5e00-4dbf-11e9-8bc7-7b0a1698b10c.png" alt="arts"></p>
<p>这里附上在Github上找到的<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="noopener">IntelliJ IDEA 简体中文专题教程</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>分享一个在阿里技术公众号上看到的一篇文章<a href="https://mp.weixin.qq.com/s/1lOvKBjL2qlRlLHP4rHONg" target="_blank" rel="noopener">《工程师男友如何反窃听？趣聊密码学入门科普》</a>，文章生动有趣，非常值得一看，妈妈再也不担心如何向别人介绍我所处的行业了<em>(:з」∠)</em> 。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/author.jpg" alt="渴望飞的哺乳类">
            
              <p class="site-author-name" itemprop="name">渴望飞的哺乳类</p>
              <p class="site-description motion-element" itemprop="description">愿你仗剑走天涯，归来仍是少年</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">渴望飞的哺乳类</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
